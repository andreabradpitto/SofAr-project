<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Baxter teleoperation project: Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Baxter teleoperation project
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Documentation for the baxter teleoperation project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Eigen</b></li><li class="navelem"><a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classEigen_1_1SparseLU-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structEigen_1_1Sparse.html">Sparse</a> supernodal LU factorization for general matrices.  
 <a href="classEigen_1_1SparseLU.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a06e96321de817132603918ea7a668ef0"><td class="memItemLeft" align="right" valign="top"><a id="a06e96321de817132603918ea7a668ef0"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>ColsAtCompileTime</b> = MatrixType::ColsAtCompileTime, 
<b>MaxColsAtCompileTime</b> = MatrixType::MaxColsAtCompileTime
 }</td></tr>
<tr class="separator:a06e96321de817132603918ea7a668ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde6955eb546fc127e96ad2c1fc087e2"><td class="memItemLeft" align="right" valign="top"><a id="afde6955eb546fc127e96ad2c1fc087e2"></a>
typedef _MatrixType&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:afde6955eb546fc127e96ad2c1fc087e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e51e8f3e71a9fec516aaecef7b778"><td class="memItemLeft" align="right" valign="top"><a id="a2e2e51e8f3e71a9fec516aaecef7b778"></a>
typedef _OrderingType&#160;</td><td class="memItemRight" valign="bottom"><b>OrderingType</b></td></tr>
<tr class="separator:a2e2e51e8f3e71a9fec516aaecef7b778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a0173a3e2ff548bc643c7c4f6c149"><td class="memItemLeft" align="right" valign="top"><a id="a105a0173a3e2ff548bc643c7c4f6c149"></a>
typedef MatrixType::Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b></td></tr>
<tr class="separator:a105a0173a3e2ff548bc643c7c4f6c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569faba9d46aee2e8ffcf396bf09089"><td class="memItemLeft" align="right" valign="top"><a id="a7569faba9d46aee2e8ffcf396bf09089"></a>
typedef MatrixType::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:a7569faba9d46aee2e8ffcf396bf09089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111a1271e3ba9a4995ff78837d816f5"><td class="memItemLeft" align="right" valign="top"><a id="a8111a1271e3ba9a4995ff78837d816f5"></a>
typedef MatrixType::StorageIndex&#160;</td><td class="memItemRight" valign="bottom"><b>StorageIndex</b></td></tr>
<tr class="separator:a8111a1271e3ba9a4995ff78837d816f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fb9b86b237b26d2148df843bc41220"><td class="memItemLeft" align="right" valign="top"><a id="af1fb9b86b237b26d2148df843bc41220"></a>
typedef <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar, ColMajor, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NCMatrix</b></td></tr>
<tr class="separator:af1fb9b86b237b26d2148df843bc41220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1629a0610cbb03e5a4fa9b508ae4a4b6"><td class="memItemLeft" align="right" valign="top"><a id="a1629a0610cbb03e5a4fa9b508ae4a4b6"></a>
typedef <a class="el" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html">internal::MappedSuperNodalMatrix</a>&lt; Scalar, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SCMatrix</b></td></tr>
<tr class="separator:a1629a0610cbb03e5a4fa9b508ae4a4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67621b3c8526fc5606a7a708427a959"><td class="memItemLeft" align="right" valign="top"><a id="ac67621b3c8526fc5606a7a708427a959"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:ac67621b3c8526fc5606a7a708427a959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2564483882d758a16067085798d3e8ad"><td class="memItemLeft" align="right" valign="top"><a id="a2564483882d758a16067085798d3e8ad"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; StorageIndex, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a2564483882d758a16067085798d3e8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c15a8364c3dea625d1f1404e7b07d1"><td class="memItemLeft" align="right" valign="top"><a id="a56c15a8364c3dea625d1f1404e7b07d1"></a>
typedef <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationMatrix</a>&lt; Dynamic, Dynamic, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>PermutationType</b></td></tr>
<tr class="separator:a56c15a8364c3dea625d1f1404e7b07d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f85e309c65f3f93cbc96a43c39336d"><td class="memItemLeft" align="right" valign="top"><a id="ae4f85e309c65f3f93cbc96a43c39336d"></a>
typedef <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">internal::SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="separator:ae4f85e309c65f3f93cbc96a43c39336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac1678e57af46b42561cea4f149861164"><td class="memItemLeft" align="right" valign="top"><a id="ac1678e57af46b42561cea4f149861164"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseLU</b> (const MatrixType &amp;matrix)</td></tr>
<tr class="separator:ac1678e57af46b42561cea4f149861164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa907ff958c4f4855145091d2686f3a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#aa907ff958c4f4855145091d2686f3a8a">analyzePattern</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="separator:aa907ff958c4f4855145091d2686f3a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39858b0e72f2659d596364e252b34cbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a39858b0e72f2659d596364e252b34cbc">factorize</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="separator:a39858b0e72f2659d596364e252b34cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4841f300341aab4999881ce7f6e38b40"><td class="memItemLeft" align="right" valign="top"><a id="a4841f300341aab4999881ce7f6e38b40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>simplicialfactorize</b> (const MatrixType &amp;matrix)</td></tr>
<tr class="separator:a4841f300341aab4999881ce7f6e38b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a8dcb02015ab9be5777d4ba9173266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a96a8dcb02015ab9be5777d4ba9173266">compute</a> (const MatrixType &amp;matrix)</td></tr>
<tr class="separator:a96a8dcb02015ab9be5777d4ba9173266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4cc6663767bbed1efd278480ee2975"><td class="memItemLeft" align="right" valign="top"><a id="a5d4cc6663767bbed1efd278480ee2975"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const</td></tr>
<tr class="separator:a5d4cc6663767bbed1efd278480ee2975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634e903f97c46b55591db2e12d1d45d1"><td class="memItemLeft" align="right" valign="top"><a id="a634e903f97c46b55591db2e12d1d45d1"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>cols</b> () const</td></tr>
<tr class="separator:a634e903f97c46b55591db2e12d1d45d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff3bd506cd78172e5219c707562729f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#afff3bd506cd78172e5219c707562729f">isSymmetric</a> (bool sym)</td></tr>
<tr class="separator:afff3bd506cd78172e5219c707562729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634abe55e5a076f2e10db78871105a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1SparseLUMatrixLReturnType.html">SparseLUMatrixLReturnType</a>&lt; <a class="el" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html">SCMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a634abe55e5a076f2e10db78871105a8f">matrixL</a> () const</td></tr>
<tr class="separator:a634abe55e5a076f2e10db78871105a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf395a8fca527144215ff19cc7b8b637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1SparseLUMatrixUReturnType.html">SparseLUMatrixUReturnType</a>&lt; <a class="el" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html">SCMatrix</a>, <a class="el" href="classEigen_1_1MappedSparseMatrix.html">MappedSparseMatrix</a>&lt; Scalar, ColMajor, StorageIndex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#aaf395a8fca527144215ff19cc7b8b637">matrixU</a> () const</td></tr>
<tr class="separator:aaf395a8fca527144215ff19cc7b8b637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691295e65c06df599876d78ac2c7fada"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a691295e65c06df599876d78ac2c7fada">rowsPermutation</a> () const</td></tr>
<tr class="separator:a691295e65c06df599876d78ac2c7fada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b0d15d0d9fd1faa164298f92ca59cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#ab7b0d15d0d9fd1faa164298f92ca59cd">colsPermutation</a> () const</td></tr>
<tr class="separator:ab7b0d15d0d9fd1faa164298f92ca59cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c726c9ebb71a60b529fe47d942ad57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a94c726c9ebb71a60b529fe47d942ad57">setPivotThreshold</a> (const RealScalar &amp;thresh)</td></tr>
<tr class="separator:a94c726c9ebb71a60b529fe47d942ad57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d0c1744ffd5a1dff578a44bcef2a3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> () const</td></tr>
<tr class="memdesc:ab0d0c1744ffd5a1dff578a44bcef2a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether previous computation was successful.  <a href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">More...</a><br /></td></tr>
<tr class="separator:ab0d0c1744ffd5a1dff578a44bcef2a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5458c4e851d7d75c8ca92c4fd02d2adb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a5458c4e851d7d75c8ca92c4fd02d2adb">lastErrorMessage</a> () const</td></tr>
<tr class="separator:a5458c4e851d7d75c8ca92c4fd02d2adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca57d33f0acf9d0d4fcf85c715b73cc6"><td class="memTemplParams" colspan="2"><a id="aca57d33f0acf9d0d4fcf85c715b73cc6"></a>
template&lt;typename Rhs , typename Dest &gt; </td></tr>
<tr class="memitem:aca57d33f0acf9d0d4fcf85c715b73cc6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_solve_impl</b> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Rhs &gt; &amp;B, <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; Dest &gt; &amp;X_base) const</td></tr>
<tr class="separator:aca57d33f0acf9d0d4fcf85c715b73cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa89424239fb169d408f08252426d0"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a06fa89424239fb169d408f08252426d0">absDeterminant</a> ()</td></tr>
<tr class="separator:a06fa89424239fb169d408f08252426d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e30a7df205596784a5a73f4768eaec"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a89e30a7df205596784a5a73f4768eaec">logAbsDeterminant</a> () const</td></tr>
<tr class="separator:a89e30a7df205596784a5a73f4768eaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6651143e3b18fa90cfb3808b6fd23c4e"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a6651143e3b18fa90cfb3808b6fd23c4e">signDeterminant</a> ()</td></tr>
<tr class="separator:a6651143e3b18fa90cfb3808b6fd23c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d63d242d27211b5c5827f5d4fd99ff"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SparseLU.html#a02d63d242d27211b5c5827f5d4fd99ff">determinant</a> ()</td></tr>
<tr class="separator:a02d63d242d27211b5c5827f5d4fd99ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c757fea6fe1d992a66524213f14fb"><td class="memTemplParams" colspan="2"><a id="a886c757fea6fe1d992a66524213f14fb"></a>
template&lt;typename Rhs , typename Dest &gt; </td></tr>
<tr class="memitem:a886c757fea6fe1d992a66524213f14fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_solve_impl</b> (const <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Rhs &gt; &amp;b, <a class="el" href="classEigen_1_1SparseMatrixBase.html">SparseMatrixBase</a>&lt; Dest &gt; &amp;dest) const</td></tr>
<tr class="separator:a886c757fea6fe1d992a66524213f14fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a9c28d06780ee2dbddcdab9861ec63c22"><td class="memItemLeft" align="right" valign="top"><a id="a9c28d06780ee2dbddcdab9861ec63c22"></a>
typedef <a class="el" href="classEigen_1_1SparseSolverBase.html">SparseSolverBase</a>&lt; <a class="el" href="classEigen_1_1SparseLU.html">SparseLU</a>&lt; _MatrixType, _OrderingType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>APIBase</b></td></tr>
<tr class="separator:a9c28d06780ee2dbddcdab9861ec63c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a38372b5d6f461e3a92fc7c8fb621b730"><td class="memItemLeft" align="right" valign="top"><a id="a38372b5d6f461e3a92fc7c8fb621b730"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initperfvalues</b> ()</td></tr>
<tr class="separator:a38372b5d6f461e3a92fc7c8fb621b730"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b8c30dd64606c6396b04c052bc88a80"><td class="memItemLeft" align="right" valign="top"><a id="a3b8c30dd64606c6396b04c052bc88a80"></a>
<a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_info</b></td></tr>
<tr class="separator:a3b8c30dd64606c6396b04c052bc88a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9049c98a8f53316c2ed9daa49c7db5"><td class="memItemLeft" align="right" valign="top"><a id="a0f9049c98a8f53316c2ed9daa49c7db5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_factorizationIsOk</b></td></tr>
<tr class="separator:a0f9049c98a8f53316c2ed9daa49c7db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a135b7a2548570384702a3d016043f6"><td class="memItemLeft" align="right" valign="top"><a id="a9a135b7a2548570384702a3d016043f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_analysisIsOk</b></td></tr>
<tr class="separator:a9a135b7a2548570384702a3d016043f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc89f4bf70115b56c4eab39d7f39a88d"><td class="memItemLeft" align="right" valign="top"><a id="abc89f4bf70115b56c4eab39d7f39a88d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>m_lastError</b></td></tr>
<tr class="separator:abc89f4bf70115b56c4eab39d7f39a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489466ddda50b9200444031544d317f"><td class="memItemLeft" align="right" valign="top"><a id="a0489466ddda50b9200444031544d317f"></a>
<a class="el" href="classEigen_1_1SparseMatrix.html">NCMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_mat</b></td></tr>
<tr class="separator:a0489466ddda50b9200444031544d317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a260e5b5860fa9e2a995d89f71234f"><td class="memItemLeft" align="right" valign="top"><a id="a33a260e5b5860fa9e2a995d89f71234f"></a>
<a class="el" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html">SCMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_Lstore</b></td></tr>
<tr class="separator:a33a260e5b5860fa9e2a995d89f71234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5866894fb3bc03bf16c1c9c04a73610f"><td class="memItemLeft" align="right" valign="top"><a id="a5866894fb3bc03bf16c1c9c04a73610f"></a>
<a class="el" href="classEigen_1_1MappedSparseMatrix.html">MappedSparseMatrix</a>&lt; Scalar, ColMajor, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_Ustore</b></td></tr>
<tr class="separator:a5866894fb3bc03bf16c1c9c04a73610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17880d2a5075b0ad2be69e9a98b18d95"><td class="memItemLeft" align="right" valign="top"><a id="a17880d2a5075b0ad2be69e9a98b18d95"></a>
<a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_perm_c</b></td></tr>
<tr class="separator:a17880d2a5075b0ad2be69e9a98b18d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0cd35485f50f819b65856f6989264a"><td class="memItemLeft" align="right" valign="top"><a id="a1d0cd35485f50f819b65856f6989264a"></a>
<a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_perm_r</b></td></tr>
<tr class="separator:a1d0cd35485f50f819b65856f6989264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bdda3c848baf65f906ad810bb67667"><td class="memItemLeft" align="right" valign="top"><a id="a93bdda3c848baf65f906ad810bb67667"></a>
<a class="el" href="classEigen_1_1Matrix.html">IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_etree</b></td></tr>
<tr class="separator:a93bdda3c848baf65f906ad810bb67667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6707db24747af79024d9dd86cbe92d32"><td class="memItemLeft" align="right" valign="top"><a id="a6707db24747af79024d9dd86cbe92d32"></a>
<a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">Base::GlobalLU_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_glu</b></td></tr>
<tr class="separator:a6707db24747af79024d9dd86cbe92d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21c4d4a3716038665e7525df123da9"><td class="memItemLeft" align="right" valign="top"><a id="abb21c4d4a3716038665e7525df123da9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_symmetricmode</b></td></tr>
<tr class="separator:abb21c4d4a3716038665e7525df123da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4b5dab545ba1f34b0d64d9a4f4fa59"><td class="memItemLeft" align="right" valign="top"><a id="a3f4b5dab545ba1f34b0d64d9a4f4fa59"></a>
<a class="el" href="structEigen_1_1internal_1_1perfvalues.html">internal::perfvalues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_perfv</b></td></tr>
<tr class="separator:a3f4b5dab545ba1f34b0d64d9a4f4fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead99552b5213cee1fada904159c289a"><td class="memItemLeft" align="right" valign="top"><a id="aead99552b5213cee1fada904159c289a"></a>
RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>m_diagpivotthresh</b></td></tr>
<tr class="separator:aead99552b5213cee1fada904159c289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe45ce540c3f7f56b01a97eaaf35825"><td class="memItemLeft" align="right" valign="top"><a id="a4fe45ce540c3f7f56b01a97eaaf35825"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_nnzL</b></td></tr>
<tr class="separator:a4fe45ce540c3f7f56b01a97eaaf35825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8298823646bfa9b71d18a03cb83c2"><td class="memItemLeft" align="right" valign="top"><a id="a60d8298823646bfa9b71d18a03cb83c2"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_nnzU</b></td></tr>
<tr class="separator:a60d8298823646bfa9b71d18a03cb83c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd9bd6741f16a8c7a616c7e11bbe05"><td class="memItemLeft" align="right" valign="top"><a id="a7cfd9bd6741f16a8c7a616c7e11bbe05"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_detPermR</b></td></tr>
<tr class="separator:a7cfd9bd6741f16a8c7a616c7e11bbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aa52a86648941a6c39b07c13d64093"><td class="memItemLeft" align="right" valign="top"><a id="a13aa52a86648941a6c39b07c13d64093"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>m_detPermC</b></td></tr>
<tr class="separator:a13aa52a86648941a6c39b07c13d64093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52101f69d048d5c4b036eadf1f13673"><td class="memItemLeft" align="right" valign="top"><a id="ac52101f69d048d5c4b036eadf1f13673"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_isInitialized</b></td></tr>
<tr class="separator:ac52101f69d048d5c4b036eadf1f13673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _MatrixType, typename _OrderingType&gt;<br />
class Eigen::SparseLU&lt; _MatrixType, _OrderingType &gt;</h3>

<p><a class="el" href="structEigen_1_1Sparse.html">Sparse</a> supernodal LU factorization for general matrices. </p>
<p>This class implements the supernodal LU factorization for general matrices. It uses the main techniques from the sequential <a class="el" href="classEigen_1_1SuperLU.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a> package (<a href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/">http://crd-legacy.lbl.gov/~xiaoye/SuperLU/</a>). It handles transparently real and complex arithmetics with single and double precision, depending on the scalar type of your input matrix. The code has been optimized to provide BLAS-3 operations during supernode-panel updates. It benefits directly from the built-in high-performant Eigen BLAS routines. Moreover, when the size of a supernode is very small, the BLAS calls are avoided to enable a better optimization from the compiler. For best performance, you should compile it with NDEBUG flag to avoid the numerous bounds checking on vectors.</p>
<p>An important parameter of this class is the ordering method. It is used to reorder the columns (and eventually the rows) of the matrix to reduce the number of new elements that are created during numerical factorization. The cheapest method available is COLAMD. See <a class="el" href="">the OrderingMethods module </a> for the list of built-in and external ordering methods.</p>
<p>Simple example with key steps </p><div class="fragment"><div class="line">VectorXd x(n), b(n);</div>
<div class="line">SparseMatrix&lt;double, ColMajor&gt; A;</div>
<div class="line">SparseLU&lt;SparseMatrix&lt;scalar, ColMajor&gt;, COLAMDOrdering&lt;Index&gt; &gt;   solver;</div>
<div class="line"><span class="comment">// fill A and b;</span></div>
<div class="line"><span class="comment">// Compute the ordering permutation vector from the structural pattern of A</span></div>
<div class="line">solver.analyzePattern(A); </div>
<div class="line"><span class="comment">// Compute the numerical factorization </span></div>
<div class="line">solver.factorize(A); </div>
<div class="line"><span class="comment">//Use the factors to solve the linear system </span></div>
<div class="line">x = solver.solve(b); </div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The input matrix A should be in a <b>compressed</b> and <b>column-major</b> form. Otherwise an expensive copy will be made. You can call the inexpensive makeCompressed() to get a compressed matrix.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike the initial <a class="el" href="classEigen_1_1SuperLU.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a> implementation, there is no step to equilibrate the matrix. For badly scaled matrices, this step can be useful to reduce the pivoting during factorization. If this is the case for your matrices, you can try the basic scaling method at "unsupported/Eigen/src/IterativeSolvers/Scaling.h"</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_MatrixType</td><td>The type of the sparse matrix. It must be a column-major SparseMatrix&lt;&gt; </td></tr>
    <tr><td class="paramname">_OrderingType</td><td>The ordering method to use, either AMD, COLAMD or METIS. Default is COLMAD</td></tr>
  </table>
  </dd>
</dl>
<p>\implsparsesolverconcept</p>
<dl class="section see"><dt>See also</dt><dd>TutorialSparseSolverConcept </dd>
<dd>
OrderingMethods_Module </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00022">22</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a06fa89424239fb169d408f08252426d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fa89424239fb169d408f08252426d0">&#9670;&nbsp;</a></span>absDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::absDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the absolute value of the determinant of the matrix of which *this is the QR decomposition.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>a determinant can be very big or small, so for matrices of large enough dimension, there is a risk of overflow/underflow. One way to work around that is to use <a class="el" href="classEigen_1_1SparseLU.html#a89e30a7df205596784a5a73f4768eaec">logAbsDeterminant()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseLU.html#a89e30a7df205596784a5a73f4768eaec">logAbsDeterminant()</a>, <a class="el" href="classEigen_1_1SparseLU.html#a6651143e3b18fa90cfb3808b6fd23c4e">signDeterminant()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00253">253</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    {</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      <span class="keyword">using</span> std::abs;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="comment">// Initialize with the determinant of the row matrix</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      Scalar det = Scalar(1.);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      <span class="comment">// Note that the diagonal blocks of U are stored in supernodes,</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      <span class="comment">// which are available in the  L part :)</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      <span class="keywordflow">for</span> (Index j = 0; j &lt; this-&gt;cols(); ++j)</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> SCMatrix::InnerIterator it(m_Lstore, j); it; ++it)</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        {</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;          <span class="keywordflow">if</span>(it.index() == j)</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;          {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            det *= abs(it.value());</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;          }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        }</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      }</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      <span class="keywordflow">return</span> det;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa907ff958c4f4855145091d2686f3a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa907ff958c4f4855145091d2686f3a8a">&#9670;&nbsp;</a></span>analyzePattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType, OrderingType &gt;::analyzePattern </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the column permutation to minimize the fill-in</p>
<ul>
<li>Apply this permutation to the input matrix -</li>
<li>Compute the column elimination tree on the permuted matrix</li>
<li>Postorder the elimination tree and the column permutation </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00411">411</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;{</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  <span class="comment">//TODO  It is possible as in SuperLU to compute row and columns scaling vectors to equilibrate the matrix mat.</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  </div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="comment">// Firstly, copy the whole input matrix. </span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  m_mat = mat;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  </div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="comment">// Compute fill-in ordering</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  OrderingType ord; </div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  ord(m_mat,m_perm_c);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  </div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;  <span class="comment">// Apply the permutation to the column of the input  matrix</span></div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  <span class="keywordflow">if</span> (m_perm_c.<a class="code" href="classEigen_1_1PermutationBase.html#a2216f9ce7b453ac39c46ff0323daeac9">size</a>())</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a7e560ebda035e992d2c99875cc7c3af3">uncompress</a>(); <span class="comment">//NOTE: The effect of this command is only to create the InnerNonzeros pointers. FIXME : This vector is filled but not subsequently used.  </span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">// Then, permute only the column pointers</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    ei_declare_aligned_stack_constructed_variable(StorageIndex,outerIndexPtr,mat.cols()+1,mat.isCompressed()?<span class="keyword">const_cast&lt;</span>StorageIndex*<span class="keyword">&gt;</span>(mat.outerIndexPtr()):0);</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="comment">// If the input matrix &#39;mat&#39; is uncompressed, then the outer-indices do not match the ones of m_mat, and a copy is thus needed.</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keywordflow">if</span>(!mat.isCompressed()) </div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;      IndexVector::Map(outerIndexPtr, mat.cols()+1) = IndexVector::Map(m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a75506964d86d6badb32d0b4917acf2e2">outerIndexPtr</a>(),mat.cols()+1);</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    </div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">// Apply the permutation and compute the nnz per column.</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; mat.cols(); i++)</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    {</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;      m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a75506964d86d6badb32d0b4917acf2e2">outerIndexPtr</a>()[m_perm_c.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>()(i)] = outerIndexPtr[i];</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;      m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a218204b051a24f579c394454786eeda0">innerNonZeroPtr</a>()[m_perm_c.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>()(i)] = outerIndexPtr[i+1] - outerIndexPtr[i];</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    }</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  }</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  </div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  <span class="comment">// Compute the column elimination tree of the permuted matrix </span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  IndexVector firstRowElt;</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;  internal::coletree(m_mat, m_etree,firstRowElt); </div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;     </div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  <span class="comment">// In symmetric mode, do not do postorder here</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  <span class="keywordflow">if</span> (!m_symmetricmode) {</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    IndexVector post, iwork; </div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="comment">// Post order etree</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    internal::treePostorder(StorageIndex(m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#aa391750e3c530227e4a5c3c52e959975">cols</a>()), m_etree, post); </div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      </div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;   </div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="comment">// Renumber etree in postorder </span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    Index m = m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#aa391750e3c530227e4a5c3c52e959975">cols</a>(); </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    iwork.resize(m+1);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; m; ++i) iwork(post(i)) = post(m_etree(i));</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    m_etree = iwork;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    </div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="comment">// Postmultiply A*Pc by post, i.e reorder the matrix according to the postorder of the etree</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    PermutationType post_perm(m); </div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; m; i++) </div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      post_perm.indices()(i) = post(i); </div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        </div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="comment">// Combine the two permutations : postorder the permutation for future use</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">if</span>(m_perm_c.<a class="code" href="classEigen_1_1PermutationBase.html#a2216f9ce7b453ac39c46ff0323daeac9">size</a>()) {</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      m_perm_c = post_perm * m_perm_c;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    }</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  } <span class="comment">// end postordering </span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  </div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  m_analysisIsOk = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7b0d15d0d9fd1faa164298f92ca59cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b0d15d0d9fd1faa164298f92ca59cd">&#9670;&nbsp;</a></span>colsPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a>&amp; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::colsPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the column matrix permutation <img class="formulaInl" alt="$ P_c^T $" src="form_172.png"/> such that <img class="formulaInl" alt="$P_r A P_c^T = L U$" src="form_171.png"/> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseLU.html#a691295e65c06df599876d78ac2c7fada">rowsPermutation()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00173">173</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <span class="keywordflow">return</span> m_perm_c;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a96a8dcb02015ab9be5777d4ba9173266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a8dcb02015ab9be5777d4ba9173266">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the symbolic and numeric factorization of the input sparse matrix. The input matrix should be in column-major storage. </p>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00124">124</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;      <span class="comment">// Analyze </span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      <a class="code" href="classEigen_1_1SparseLU.html#aa907ff958c4f4855145091d2686f3a8a">analyzePattern</a>(matrix); </div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      <span class="comment">//Factorize</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      <a class="code" href="classEigen_1_1SparseLU.html#a39858b0e72f2659d596364e252b34cbc">factorize</a>(matrix);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    } </div>
</div><!-- fragment -->
</div>
</div>
<a id="a02d63d242d27211b5c5827f5d4fd99ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d63d242d27211b5c5827f5d4fd99ff">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseLU.html#a06fa89424239fb169d408f08252426d0">absDeterminant()</a>, <a class="el" href="classEigen_1_1SparseLU.html#a89e30a7df205596784a5a73f4768eaec">logAbsDeterminant()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00337">337</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    {</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;      <span class="comment">// Initialize with the determinant of the row matrix</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;      Scalar det = Scalar(1.);</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;      <span class="comment">// Note that the diagonal blocks of U are stored in supernodes,</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <span class="comment">// which are available in the  L part :)</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      <span class="keywordflow">for</span> (Index j = 0; j &lt; this-&gt;cols(); ++j)</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      {</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> SCMatrix::InnerIterator it(m_Lstore, j); it; ++it)</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;          <span class="keywordflow">if</span>(it.index() == j)</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;          {</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            det *= it.value();</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;          }</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;      }</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      <span class="keywordflow">return</span> (m_detPermR * m_detPermC) &gt; 0 ? det : -det;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a39858b0e72f2659d596364e252b34cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39858b0e72f2659d596364e252b34cbc">&#9670;&nbsp;</a></span>factorize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename OrderingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; MatrixType, OrderingType &gt;::factorize </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ul>
<li>Numerical factorization</li>
<li><p class="startli">Interleaved with the symbolic factorization On exit, info is</p>
<p class="startli">= 0: successful factorization</p>
</li>
</ul>
<blockquote class="doxtable">
<p>0: if info = i, and i is </p>
</blockquote>
<pre class="fragment">  &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
     been completed, but the factor U is exactly singular,
     and division by zero will occur if it is used to solve a
     system of equations.

  &gt; A-&gt;ncol: number of bytes allocated when memory allocation
    failure occurred, plus A-&gt;ncol. If lwork = -1, it is
    the estimated amount of space needed, plus A-&gt;ncol.  
</pre> 
<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00496">496</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;{</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;  <span class="keyword">using</span> internal::emptyIdxLU;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  eigen_assert(m_analysisIsOk &amp;&amp; <span class="stringliteral">&quot;analyzePattern() should be called first&quot;</span>); </div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  eigen_assert((matrix.rows() == matrix.cols()) &amp;&amp; <span class="stringliteral">&quot;Only for squared matrices&quot;</span>);</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  </div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  m_isInitialized = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  </div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;  </div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;  <span class="comment">// Apply the column permutation computed in analyzepattern()</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  <span class="comment">//   m_mat = matrix * m_perm_c.inverse(); </span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  m_mat = matrix;</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  <span class="keywordflow">if</span> (m_perm_c.<a class="code" href="classEigen_1_1PermutationBase.html#a2216f9ce7b453ac39c46ff0323daeac9">size</a>()) </div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  {</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a7e560ebda035e992d2c99875cc7c3af3">uncompress</a>(); <span class="comment">//NOTE: The effect of this command is only to create the InnerNonzeros pointers.</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="comment">//Then, permute only the column pointers</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    <span class="keyword">const</span> StorageIndex * outerIndexPtr;</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="keywordflow">if</span> (matrix.isCompressed()) outerIndexPtr = matrix.outerIndexPtr();</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    {</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;      StorageIndex* outerIndexPtr_t = <span class="keyword">new</span> StorageIndex[matrix.cols()+1];</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;      <span class="keywordflow">for</span>(Index i = 0; i &lt;= matrix.cols(); i++) outerIndexPtr_t[i] = m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a75506964d86d6badb32d0b4917acf2e2">outerIndexPtr</a>()[i];</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;      outerIndexPtr = outerIndexPtr_t;</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    }</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="keywordflow">for</span> (Index i = 0; i &lt; matrix.cols(); i++)</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    {</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;      m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a75506964d86d6badb32d0b4917acf2e2">outerIndexPtr</a>()[m_perm_c.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>()(i)] = outerIndexPtr[i];</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a218204b051a24f579c394454786eeda0">innerNonZeroPtr</a>()[m_perm_c.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>()(i)] = outerIndexPtr[i+1] - outerIndexPtr[i];</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    }</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="keywordflow">if</span>(!matrix.isCompressed()) <span class="keyword">delete</span>[] outerIndexPtr;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  } </div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;  <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  { <span class="comment">//FIXME This should not be needed if the empty permutation is handled transparently</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    m_perm_c.<a class="code" href="classEigen_1_1PermutationBase.html#a0e0fda6e84d69e02432e4770359bb532">resize</a>(matrix.cols());</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="keywordflow">for</span>(StorageIndex i = 0; i &lt; matrix.cols(); ++i) m_perm_c.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>()(i) = i;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  }</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  </div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  Index m = m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a62e61bb861eee306d5b069ce652b5aa5">rows</a>();</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  Index n = m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#aa391750e3c530227e4a5c3c52e959975">cols</a>();</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  Index nnz = m_mat.<a class="code" href="classEigen_1_1SparseMatrix.html#a03de8b3da2c142ce8698a76123b3e7d3">nonZeros</a>();</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  Index maxpanel = m_perfv.panel_size * m;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  <span class="comment">// Allocate working storage common to the factor routines</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  Index lwork = 0;</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  Index <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> = <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#ac018b8ed9664d4e19e34f1ff2d6c578a">Base::memInit</a>(m, n, nnz, lwork, m_perfv.fillfactor, m_perfv.panel_size, m_glu); </div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a>) </div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  {</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    m_lastError = <span class="stringliteral">&quot;UNABLE TO ALLOCATE WORKING MEMORY\n\n&quot;</span> ;</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    m_factorizationIsOk = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    return ; </div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;  }</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  </div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="comment">// Set up pointers for integer working arrays </span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  IndexVector segrep(m); segrep.setZero();</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  IndexVector parent(m); parent.setZero();</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  IndexVector xplore(m); xplore.setZero();</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  IndexVector repfnz(maxpanel);</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  IndexVector panel_lsub(maxpanel);</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  IndexVector xprune(n); xprune.setZero();</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  IndexVector marker(m*internal::LUNoMarker); marker.setZero();</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;  </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  repfnz.setConstant(-1); </div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  panel_lsub.setConstant(-1);</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  </div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  <span class="comment">// Set up pointers for scalar working arrays </span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  ScalarVector dense; </div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;  dense.<a class="code" href="classEigen_1_1PlainObjectBase.html#ac21ad5f989f320e46958b75ac8d9a1da">setZero</a>(maxpanel);</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  ScalarVector tempv; </div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  tempv.<a class="code" href="classEigen_1_1PlainObjectBase.html#ac21ad5f989f320e46958b75ac8d9a1da">setZero</a>(internal::LUnumTempV(m, m_perfv.panel_size, m_perfv.maxsuper, <span class="comment">/*m_perfv.rowblk*/</span>m) );</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  </div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  <span class="comment">// Compute the inverse of perm_c</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  PermutationType iperm_c(m_perm_c.<a class="code" href="classEigen_1_1PermutationBase.html#adb9af427f317202366c2832876064eb3">inverse</a>()); </div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  </div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  <span class="comment">// Identify initial relaxed snodes</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  IndexVector relax_end(n);</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  <span class="keywordflow">if</span> ( m_symmetricmode == <span class="keyword">true</span> ) </div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#a88952ce33c968374b149e31d0539178d">Base::heap_relax_snode</a>(n, m_etree, m_perfv.relax, marker, relax_end);</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#a33672df380f94e774c5a6919d3474af4">Base::relax_snode</a>(n, m_etree, m_perfv.relax, marker, relax_end);</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  </div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  </div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;  m_perm_r.<a class="code" href="classEigen_1_1PermutationBase.html#a0e0fda6e84d69e02432e4770359bb532">resize</a>(m); </div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;  m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>().setConstant(-1);</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  marker.setConstant(-1);</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;  m_detPermR = 1; <span class="comment">// Record the determinant of the row permutation</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  </div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  m_glu.supno(0) = emptyIdxLU; m_glu.xsup.<a class="code" href="classEigen_1_1PlainObjectBase.html#ac8dea1df3d92b752cc683ff42abf6f9b">setConstant</a>(0);</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;  m_glu.xsup(0) = m_glu.xlsub(0) = m_glu.xusub(0) = m_glu.xlusup(0) = Index(0);</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;  </div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  <span class="comment">// Work on one &#39;panel&#39; at a time. A panel is one of the following :</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  <span class="comment">//  (a) a relaxed supernode at the bottom of the etree, or</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  <span class="comment">//  (b) panel_size contiguous columns, &lt;panel_size&gt; defined by the user</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  Index jcol; </div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  IndexVector panel_histo(n);</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  Index pivrow; <span class="comment">// Pivotal row number in the original row matrix</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  Index nseg1; <span class="comment">// Number of segments in U-column above panel row jcol</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  Index nseg; <span class="comment">// Number of segments in each U-column </span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  Index irep; </div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  Index i, k, jj; </div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;  <span class="keywordflow">for</span> (jcol = 0; jcol &lt; n; )</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  {</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    <span class="comment">// Adjust panel size so that a panel won&#39;t overlap with the next relaxed snode. </span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    Index panel_size = m_perfv.panel_size; <span class="comment">// upper bound on panel width</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">for</span> (k = jcol + 1; k &lt; (std::min)(jcol+panel_size, n); k++)</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    {</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      <span class="keywordflow">if</span> (relax_end(k) != emptyIdxLU) </div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      {</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        panel_size = k - jcol; </div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="keywordflow">break</span>; </div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;      }</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    }</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    <span class="keywordflow">if</span> (k == n) </div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      panel_size = n - jcol; </div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      </div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="comment">// Symbolic outer factorization on a panel of columns </span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#acaf62fda387ea03e9caa2734e4e7b0c9">Base::panel_dfs</a>(m, panel_size, jcol, m_mat, m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>(), nseg1, dense, panel_lsub, segrep, repfnz, xprune, marker, parent, xplore, m_glu); </div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    </div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    <span class="comment">// Numeric sup-panel updates in topological order </span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#a277936738db49e25285164ac25c498c3">Base::panel_bmod</a>(m, panel_size, jcol, nseg1, dense, tempv, segrep, repfnz, m_glu); </div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;    </div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    <span class="comment">// Sparse LU within the panel, and below the panel diagonal </span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;    <span class="keywordflow">for</span> ( jj = jcol; jj&lt; jcol + panel_size; jj++) </div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    {</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;      k = (jj - jcol) * m; <span class="comment">// Column index for w-wide arrays </span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;      </div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;      nseg = nseg1; <span class="comment">// begin after all the panel segments</span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;      <span class="comment">//Depth-first-search for the current column</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      VectorBlock&lt;IndexVector&gt; panel_lsubk(panel_lsub, k, m);</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;      VectorBlock&lt;IndexVector&gt; repfnz_k(repfnz, k, m); </div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;      <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> = <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#a6f543ae02eb6467e9bcc1e5cec8ccdd2">Base::column_dfs</a>(m, jj, m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>(), m_perfv.maxsuper, nseg, panel_lsubk, segrep, repfnz_k, xprune, marker, parent, xplore, m_glu); </div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;      <span class="keywordflow">if</span> ( <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> ) </div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;      {</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;        m_lastError =  <span class="stringliteral">&quot;UNABLE TO EXPAND MEMORY IN COLUMN_DFS() &quot;</span>;</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <span class="keywordflow">return</span>; </div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      }</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      <span class="comment">// Numeric updates to this column </span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;      VectorBlock&lt;ScalarVector&gt; dense_k(dense, k, m); </div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;      VectorBlock&lt;IndexVector&gt; segrep_k(segrep, nseg1, m-nseg1); </div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> = <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#ae34275602cf12560edfcaf7cd5cbe932">Base::column_bmod</a>(jj, (nseg - nseg1), dense_k, tempv, segrep_k, repfnz_k, jcol, m_glu); </div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;      <span class="keywordflow">if</span> ( <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> ) </div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;      {</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        m_lastError = <span class="stringliteral">&quot;UNABLE TO EXPAND MEMORY IN COLUMN_BMOD() &quot;</span>;</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        <span class="keywordflow">return</span>; </div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;      }</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;      </div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      <span class="comment">// Copy the U-segments to ucol(*)</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;      <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> = <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#ae4867ed1d5f104f9245411c356416a21">Base::copy_to_ucol</a>(jj, nseg, segrep, repfnz_k ,m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>(), dense_k, m_glu); </div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;      <span class="keywordflow">if</span> ( <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> ) </div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;      {</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;        m_lastError = <span class="stringliteral">&quot;UNABLE TO EXPAND MEMORY IN COPY_TO_UCOL() &quot;</span>;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        <span class="keywordflow">return</span>; </div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;      }</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;      </div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;      <span class="comment">// Form the L-segment </span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;      <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> = <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#ab5f56947465b829f8d523575724c3ac6">Base::pivotL</a>(jj, m_diagpivotthresh, m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>(), iperm_c.indices(), pivrow, m_glu);</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;      <span class="keywordflow">if</span> ( <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a> ) </div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;      {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;        m_lastError = <span class="stringliteral">&quot;THE MATRIX IS STRUCTURALLY SINGULAR ... ZERO COLUMN AT &quot;</span>;</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;        std::ostringstream returnInfo;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        returnInfo &lt;&lt; <a class="code" href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">info</a>; </div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;        m_lastError += returnInfo.str();</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">NumericalIssue</a>; </div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        m_factorizationIsOk = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="keywordflow">return</span>; </div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;      }</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;      </div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;      <span class="comment">// Update the determinant of the row permutation matrix</span></div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;      <span class="comment">// FIXME: the following test is not correct, we should probably take iperm_c into account and pivrow is not directly the row pivot.</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;      <span class="keywordflow">if</span> (pivrow != jj) m_detPermR = -m_detPermR;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160; </div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;      <span class="comment">// Prune columns (0:jj-1) using column jj</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;      <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#a350464d1c83182fbd7da8a5a74bdfde8">Base::pruneL</a>(jj, m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>(), pivrow, nseg, segrep, repfnz_k, xprune, m_glu); </div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;      </div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;      <span class="comment">// Reset repfnz for this column </span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;      <span class="keywordflow">for</span> (i = 0; i &lt; nseg; i++)</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;      {</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        irep = segrep(i); </div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        repfnz_k(irep) = emptyIdxLU; </div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;      }</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    } <span class="comment">// end SparseLU within the panel  </span></div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    jcol += panel_size;  <span class="comment">// Move to the next panel</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  } <span class="comment">// end for -- end elimination </span></div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;  </div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  m_detPermR = m_perm_r.<a class="code" href="classEigen_1_1PermutationBase.html#a1fc7a5823544700c2e0795e87f9c6d09">determinant</a>();</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;  m_detPermC = m_perm_c.<a class="code" href="classEigen_1_1PermutationBase.html#a1fc7a5823544700c2e0795e87f9c6d09">determinant</a>();</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  </div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;  <span class="comment">// Count the number of nonzeros in factors </span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#acbede3f259186d48ad42ca093f80b64b">Base::countnz</a>(n, m_nnzL, m_nnzU, m_glu); </div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  <span class="comment">// Apply permutation  to the L subscripts </span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  <a class="code" href="classEigen_1_1internal_1_1SparseLUImpl.html#ae1d1ed091956ff4e5734b4e3f79f866e">Base::fixupL</a>(n, m_perm_r.<a class="code" href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">indices</a>(), m_glu);</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;  </div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  <span class="comment">// Create supernode matrix L </span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  m_Lstore.<a class="code" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html#af1427486564e2c75b9da68f98bd04e63">setInfos</a>(m, n, m_glu.lusup, m_glu.xlusup, m_glu.lsub, m_glu.xlsub, m_glu.supno, m_glu.xsup); </div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  <span class="comment">// Create the column major upper sparse matrix  U; </span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;  <span class="keyword">new</span> (&amp;m_Ustore) MappedSparseMatrix&lt;Scalar, ColMajor, StorageIndex&gt; ( m, n, m_nnzU, m_glu.xusub.<a class="code" href="classEigen_1_1PlainObjectBase.html#ac25699535374b1854cf8494e44ad31b2">data</a>(), m_glu.usub.<a class="code" href="classEigen_1_1PlainObjectBase.html#ac25699535374b1854cf8494e44ad31b2">data</a>(), m_glu.ucol.<a class="code" href="classEigen_1_1PlainObjectBase.html#ac25699535374b1854cf8494e44ad31b2">data</a>() );</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  </div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  m_info = <a class="code" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Success</a>;</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  m_factorizationIsOk = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0d0c1744ffd5a1dff578a44bcef2a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d0c1744ffd5a1dff578a44bcef2a3d">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether previous computation was successful. </p>
<dl class="section return"><dt>Returns</dt><dd><code>Success</code> if computation was succesful, <code>NumericalIssue</code> if the LU factorization reports a problem, zero diagonal for instance <code>InvalidInput</code> if the input matrix is invalid</dd></dl>
<dl class="section see"><dt>See also</dt><dd>iparm() <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00202">202</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      eigen_assert(m_isInitialized &amp;&amp; <span class="stringliteral">&quot;Decomposition is not initialized.&quot;</span>);</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      <span class="keywordflow">return</span> m_info;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afff3bd506cd78172e5219c707562729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff3bd506cd78172e5219c707562729f">&#9670;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::isSymmetric </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sym</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate that the pattern of the input matrix is symmetric </p>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00135">135</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    {</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;      m_symmetricmode = sym;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5458c4e851d7d75c8ca92c4fd02d2adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5458c4e851d7d75c8ca92c4fd02d2adb">&#9670;&nbsp;</a></span>lastErrorMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::lastErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A string describing the type of error </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00211">211</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      <span class="keywordflow">return</span> m_lastError; </div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a89e30a7df205596784a5a73f4768eaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e30a7df205596784a5a73f4768eaec">&#9670;&nbsp;</a></span>logAbsDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::logAbsDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the natural log of the absolute value of the determinant of the matrix of which **this is the QR decomposition</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is useful to work around the risk of overflow/underflow that's inherent to the determinant computation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseLU.html#a06fa89424239fb169d408f08252426d0">absDeterminant()</a>, <a class="el" href="classEigen_1_1SparseLU.html#a6651143e3b18fa90cfb3808b6fd23c4e">signDeterminant()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00283">283</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    {</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      <span class="keyword">using</span> std::log;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;      <span class="keyword">using</span> std::abs;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160; </div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      Scalar det = Scalar(0.);</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      <span class="keywordflow">for</span> (Index j = 0; j &lt; this-&gt;cols(); ++j)</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      {</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> SCMatrix::InnerIterator it(m_Lstore, j); it; ++it)</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;          <span class="keywordflow">if</span>(it.row() &lt; j) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;          <span class="keywordflow">if</span>(it.row() == j)</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;          {</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            det += log(abs(it.value()));</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;          }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;      }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <span class="keywordflow">return</span> det;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a634abe55e5a076f2e10db78871105a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634abe55e5a076f2e10db78871105a8f">&#9670;&nbsp;</a></span>matrixL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1SparseLUMatrixLReturnType.html">SparseLUMatrixLReturnType</a>&lt;<a class="el" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html">SCMatrix</a>&gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::matrixL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix L, internally stored as supernodes The only operation available with this expression is the triangular solve <div class="fragment"><div class="line">y = b; <a class="code" href="classEigen_1_1SparseLU.html#a634abe55e5a076f2e10db78871105a8f">matrixL</a>().solveInPlace(y);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00146">146</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;      <span class="keywordflow">return</span> SparseLUMatrixLReturnType&lt;SCMatrix&gt;(m_Lstore);</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf395a8fca527144215ff19cc7b8b637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf395a8fca527144215ff19cc7b8b637">&#9670;&nbsp;</a></span>matrixU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1SparseLUMatrixUReturnType.html">SparseLUMatrixUReturnType</a>&lt;<a class="el" href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html">SCMatrix</a>,<a class="el" href="classEigen_1_1MappedSparseMatrix.html">MappedSparseMatrix</a>&lt;Scalar,ColMajor,StorageIndex&gt; &gt; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::matrixU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the matrix U, The only operation available with this expression is the triangular solve <div class="fragment"><div class="line">y = b; <a class="code" href="classEigen_1_1SparseLU.html#aaf395a8fca527144215ff19cc7b8b637">matrixU</a>().solveInPlace(y);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00156">156</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      <span class="keywordflow">return</span> SparseLUMatrixUReturnType&lt;SCMatrix, MappedSparseMatrix&lt;Scalar,ColMajor,StorageIndex&gt; &gt;(m_Lstore, m_Ustore);</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a691295e65c06df599876d78ac2c7fada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691295e65c06df599876d78ac2c7fada">&#9670;&nbsp;</a></span>rowsPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PermutationMatrix.html">PermutationType</a>&amp; <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::rowsPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to the row matrix permutation <img class="formulaInl" alt="$ P_r $" src="form_170.png"/> such that <img class="formulaInl" alt="$P_r A P_c^T = L U$" src="form_171.png"/> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseLU.html#ab7b0d15d0d9fd1faa164298f92ca59cd">colsPermutation()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00165">165</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordflow">return</span> m_perm_r;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94c726c9ebb71a60b529fe47d942ad57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c726c9ebb71a60b529fe47d942ad57">&#9670;&nbsp;</a></span>setPivotThreshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::setPivotThreshold </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>thresh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the threshold used for a diagonal entry to be an acceptable pivot. </p>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00178">178</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      m_diagpivotthresh = thresh; </div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6651143e3b18fa90cfb3808b6fd23c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6651143e3b18fa90cfb3808b6fd23c4e">&#9670;&nbsp;</a></span>signDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _MatrixType , typename _OrderingType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classEigen_1_1SparseLU.html">Eigen::SparseLU</a>&lt; _MatrixType, _OrderingType &gt;::signDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A number representing the sign of the determinant</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1SparseLU.html#a06fa89424239fb169d408f08252426d0">absDeterminant()</a>, <a class="el" href="classEigen_1_1SparseLU.html#a89e30a7df205596784a5a73f4768eaec">logAbsDeterminant()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU_8h_source.html#l00309">309</a> of file <a class="el" href="SparseLU_8h_source.html">SparseLU.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;      eigen_assert(m_factorizationIsOk &amp;&amp; <span class="stringliteral">&quot;The matrix should be factorized first.&quot;</span>);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;      <span class="comment">// Initialize with the determinant of the row matrix</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;      Index det = 1;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;      <span class="comment">// Note that the diagonal blocks of U are stored in supernodes,</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;      <span class="comment">// which are available in the  L part :)</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;      <span class="keywordflow">for</span> (Index j = 0; j &lt; this-&gt;cols(); ++j)</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;      {</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> SCMatrix::InnerIterator it(m_Lstore, j); it; ++it)</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        {</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;          <span class="keywordflow">if</span>(it.index() == j)</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;          {</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keywordflow">if</span>(it.value()&lt;0)</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;              det = -det;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(it.value()==0)</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;              <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;          }</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;      }</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;      <span class="keywordflow">return</span> det * m_detPermR * m_detPermC;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU_8h_source.html">SparseLU.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_aa391750e3c530227e4a5c3c52e959975"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html#aa391750e3c530227e4a5c3c52e959975">Eigen::SparseMatrix::cols</a></div><div class="ttdeci">Index cols() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseMatrix_8h_source.html#l00138">SparseMatrix.h:138</a></div></div>
<div class="ttc" id="agroup__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea1c6e20706575a629b27a105f07f1883b">Eigen::NumericalIssue</a></div><div class="ttdeci">@ NumericalIssue</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00434">Constants.h:434</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_aa907ff958c4f4855145091d2686f3a8a"><div class="ttname"><a href="classEigen_1_1SparseLU.html#aa907ff958c4f4855145091d2686f3a8a">Eigen::SparseLU::analyzePattern</a></div><div class="ttdeci">void analyzePattern(const MatrixType &amp;matrix)</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU_8h_source.html#l00411">SparseLU.h:411</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_ae1d1ed091956ff4e5734b4e3f79f866e"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#ae1d1ed091956ff4e5734b4e3f79f866e">Eigen::internal::SparseLUImpl::fixupL</a></div><div class="ttdeci">void fixupL(const Index n, const IndexVector &amp;perm_r, GlobalLU_t &amp;glu)</div><div class="ttdoc">Fix up the data storage lsub for L-subscripts.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__Utils_8h_source.html#l00052">SparseLU_Utils.h:52</a></div></div>
<div class="ttc" id="aclassEigen_1_1PermutationMatrix_html_a2f1ab379207fcd1ceb33941e25cf50c2"><div class="ttname"><a href="classEigen_1_1PermutationMatrix.html#a2f1ab379207fcd1ceb33941e25cf50c2">Eigen::PermutationMatrix::indices</a></div><div class="ttdeci">const IndicesType &amp; indices() const</div><div class="ttdef"><b>Definition:</b> <a href="PermutationMatrix_8h_source.html#l00388">PermutationMatrix.h:388</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_a6f543ae02eb6467e9bcc1e5cec8ccdd2"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#a6f543ae02eb6467e9bcc1e5cec8ccdd2">Eigen::internal::SparseLUImpl::column_dfs</a></div><div class="ttdeci">Index column_dfs(const Index m, const Index jcol, IndexVector &amp;perm_r, Index maxsuper, Index &amp;nseg, BlockIndexVector lsub_col, IndexVector &amp;segrep, BlockIndexVector repfnz, IndexVector &amp;xprune, IndexVector &amp;marker, IndexVector &amp;parent, IndexVector &amp;xplore, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs a symbolic factorization on column jcol and decide the supernode boundary.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__column__dfs_8h_source.html#l00093">SparseLU_column_dfs.h:93</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a7e560ebda035e992d2c99875cc7c3af3"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html#a7e560ebda035e992d2c99875cc7c3af3">Eigen::SparseMatrix::uncompress</a></div><div class="ttdeci">void uncompress()</div><div class="ttdef"><b>Definition:</b> <a href="SparseMatrix_8h_source.html#l00495">SparseMatrix.h:495</a></div></div>
<div class="ttc" id="agroup__enums_html_gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf"><div class="ttname"><a href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea671a2aeb0f527802806a441d58a80fcf">Eigen::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00432">Constants.h:432</a></div></div>
<div class="ttc" id="aclassEigen_1_1PermutationBase_html_a0e0fda6e84d69e02432e4770359bb532"><div class="ttname"><a href="classEigen_1_1PermutationBase.html#a0e0fda6e84d69e02432e4770359bb532">Eigen::PermutationBase::resize</a></div><div class="ttdeci">void resize(Index newSize)</div><div class="ttdef"><b>Definition:</b> <a href="PermutationMatrix_8h_source.html#l00136">PermutationMatrix.h:136</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a39858b0e72f2659d596364e252b34cbc"><div class="ttname"><a href="classEigen_1_1SparseLU.html#a39858b0e72f2659d596364e252b34cbc">Eigen::SparseLU::factorize</a></div><div class="ttdeci">void factorize(const MatrixType &amp;matrix)</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU_8h_source.html#l00496">SparseLU.h:496</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_a88952ce33c968374b149e31d0539178d"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#a88952ce33c968374b149e31d0539178d">Eigen::internal::SparseLUImpl::heap_relax_snode</a></div><div class="ttdeci">void heap_relax_snode(const Index n, IndexVector &amp;et, const Index relax_columns, IndexVector &amp;descendants, IndexVector &amp;relax_end)</div><div class="ttdoc">Identify the initial relaxed supernodes.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__heap__relax__snode_8h_source.html#l00046">SparseLU_heap_relax_snode.h:46</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_ae4867ed1d5f104f9245411c356416a21"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#ae4867ed1d5f104f9245411c356416a21">Eigen::internal::SparseLUImpl::copy_to_ucol</a></div><div class="ttdeci">Index copy_to_ucol(const Index jcol, const Index nseg, IndexVector &amp;segrep, BlockIndexVector repfnz, IndexVector &amp;perm_r, BlockScalarVector dense, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs numeric block updates (sup-col) in topological order.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__copy__to__ucol_8h_source.html#l00050">SparseLU_copy_to_ucol.h:50</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_a634abe55e5a076f2e10db78871105a8f"><div class="ttname"><a href="classEigen_1_1SparseLU.html#a634abe55e5a076f2e10db78871105a8f">Eigen::SparseLU::matrixL</a></div><div class="ttdeci">SparseLUMatrixLReturnType&lt; SCMatrix &gt; matrixL() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU_8h_source.html#l00146">SparseLU.h:146</a></div></div>
<div class="ttc" id="aclassEigen_1_1PlainObjectBase_html_ac8dea1df3d92b752cc683ff42abf6f9b"><div class="ttname"><a href="classEigen_1_1PlainObjectBase.html#ac8dea1df3d92b752cc683ff42abf6f9b">Eigen::PlainObjectBase::setConstant</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC Derived &amp; setConstant(Index size, const Scalar &amp;val)</div><div class="ttdef"><b>Definition:</b> <a href="CwiseNullaryOp_8h_source.html#l00341">CwiseNullaryOp.h:341</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_ae34275602cf12560edfcaf7cd5cbe932"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#ae34275602cf12560edfcaf7cd5cbe932">Eigen::internal::SparseLUImpl::column_bmod</a></div><div class="ttdeci">Index column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector &amp;tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs numeric block updates (sup-col) in topological order.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__column__bmod_8h_source.html#l00053">SparseLU_column_bmod.h:53</a></div></div>
<div class="ttc" id="aclassEigen_1_1PermutationBase_html_a2216f9ce7b453ac39c46ff0323daeac9"><div class="ttname"><a href="classEigen_1_1PermutationBase.html#a2216f9ce7b453ac39c46ff0323daeac9">Eigen::PermutationBase::size</a></div><div class="ttdeci">Index size() const</div><div class="ttdef"><b>Definition:</b> <a href="PermutationMatrix_8h_source.html#l00108">PermutationMatrix.h:108</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_a277936738db49e25285164ac25c498c3"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#a277936738db49e25285164ac25c498c3">Eigen::internal::SparseLUImpl::panel_bmod</a></div><div class="ttdeci">void panel_bmod(const Index m, const Index w, const Index jcol, const Index nseg, ScalarVector &amp;dense, ScalarVector &amp;tempv, IndexVector &amp;segrep, IndexVector &amp;repfnz, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs numeric block updates (sup-panel) in topological order.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__panel__bmod_8h_source.html#l00056">SparseLU_panel_bmod.h:56</a></div></div>
<div class="ttc" id="aclassEigen_1_1PermutationBase_html_adb9af427f317202366c2832876064eb3"><div class="ttname"><a href="classEigen_1_1PermutationBase.html#adb9af427f317202366c2832876064eb3">Eigen::PermutationBase::inverse</a></div><div class="ttdeci">InverseReturnType inverse() const</div><div class="ttdef"><b>Definition:</b> <a href="PermutationMatrix_8h_source.html#l00196">PermutationMatrix.h:196</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a218204b051a24f579c394454786eeda0"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html#a218204b051a24f579c394454786eeda0">Eigen::SparseMatrix::innerNonZeroPtr</a></div><div class="ttdeci">const StorageIndex * innerNonZeroPtr() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseMatrix_8h_source.html#l00175">SparseMatrix.h:175</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1MappedSuperNodalMatrix_html_af1427486564e2c75b9da68f98bd04e63"><div class="ttname"><a href="classEigen_1_1internal_1_1MappedSuperNodalMatrix.html#af1427486564e2c75b9da68f98bd04e63">Eigen::internal::MappedSuperNodalMatrix::setInfos</a></div><div class="ttdeci">void setInfos(Index m, Index n, ScalarVector &amp;nzval, IndexVector &amp;nzval_colptr, IndexVector &amp;rowind, IndexVector &amp;rowind_colptr, IndexVector &amp;col_to_sup, IndexVector &amp;sup_to_col)</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__SupernodalMatrix_8h_source.html#l00061">SparseLU_SupernodalMatrix.h:61</a></div></div>
<div class="ttc" id="aclassEigen_1_1PermutationBase_html_a1fc7a5823544700c2e0795e87f9c6d09"><div class="ttname"><a href="classEigen_1_1PermutationBase.html#a1fc7a5823544700c2e0795e87f9c6d09">Eigen::PermutationBase::determinant</a></div><div class="ttdeci">Index determinant() const</div><div class="ttdef"><b>Definition:</b> <a href="PermutationMatrix_8h_source.html#l00253">PermutationMatrix.h:253</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a75506964d86d6badb32d0b4917acf2e2"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html#a75506964d86d6badb32d0b4917acf2e2">Eigen::SparseMatrix::outerIndexPtr</a></div><div class="ttdeci">const StorageIndex * outerIndexPtr() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseMatrix_8h_source.html#l00166">SparseMatrix.h:166</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_a350464d1c83182fbd7da8a5a74bdfde8"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#a350464d1c83182fbd7da8a5a74bdfde8">Eigen::internal::SparseLUImpl::pruneL</a></div><div class="ttdeci">void pruneL(const Index jcol, const IndexVector &amp;perm_r, const Index pivrow, const Index nseg, const IndexVector &amp;segrep, BlockIndexVector repfnz, IndexVector &amp;xprune, GlobalLU_t &amp;glu)</div><div class="ttdoc">Prunes the L-structure.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__pruneL_8h_source.html#l00053">SparseLU_pruneL.h:53</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a03de8b3da2c142ce8698a76123b3e7d3"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html#a03de8b3da2c142ce8698a76123b3e7d3">Eigen::SparseMatrix::nonZeros</a></div><div class="ttdeci">Index nonZeros() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseCompressedBase_8h_source.html#l00056">SparseCompressedBase.h:56</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_ac018b8ed9664d4e19e34f1ff2d6c578a"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#ac018b8ed9664d4e19e34f1ff2d6c578a">Eigen::internal::SparseLUImpl::memInit</a></div><div class="ttdeci">Index memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, GlobalLU_t &amp;glu)</div><div class="ttdoc">Allocate various working space for the numerical factorization phase.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__Memory_8h_source.html#l00151">SparseLU_Memory.h:151</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_aaf395a8fca527144215ff19cc7b8b637"><div class="ttname"><a href="classEigen_1_1SparseLU.html#aaf395a8fca527144215ff19cc7b8b637">Eigen::SparseLU::matrixU</a></div><div class="ttdeci">SparseLUMatrixUReturnType&lt; SCMatrix, MappedSparseMatrix&lt; Scalar, ColMajor, StorageIndex &gt; &gt; matrixU() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU_8h_source.html#l00156">SparseLU.h:156</a></div></div>
<div class="ttc" id="aclassEigen_1_1PlainObjectBase_html_ac21ad5f989f320e46958b75ac8d9a1da"><div class="ttname"><a href="classEigen_1_1PlainObjectBase.html#ac21ad5f989f320e46958b75ac8d9a1da">Eigen::PlainObjectBase::setZero</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC Derived &amp; setZero(Index size)</div><div class="ttdef"><b>Definition:</b> <a href="CwiseNullaryOp_8h_source.html#l00515">CwiseNullaryOp.h:515</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_a33672df380f94e774c5a6919d3474af4"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#a33672df380f94e774c5a6919d3474af4">Eigen::internal::SparseLUImpl::relax_snode</a></div><div class="ttdeci">void relax_snode(const Index n, IndexVector &amp;et, const Index relax_columns, IndexVector &amp;descendants, IndexVector &amp;relax_end)</div><div class="ttdoc">Identify the initial relaxed supernodes.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__relax__snode_8h_source.html#l00047">SparseLU_relax_snode.h:47</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_ab5f56947465b829f8d523575724c3ac6"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#ab5f56947465b829f8d523575724c3ac6">Eigen::internal::SparseLUImpl::pivotL</a></div><div class="ttdeci">Index pivotL(const Index jcol, const RealScalar &amp;diagpivotthresh, IndexVector &amp;perm_r, IndexVector &amp;iperm_c, Index &amp;pivrow, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs the numerical pivotin on the current column of L, and the CDIV operation.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__pivotL_8h_source.html#l00060">SparseLU_pivotL.h:60</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseMatrix_html_a62e61bb861eee306d5b069ce652b5aa5"><div class="ttname"><a href="classEigen_1_1SparseMatrix.html#a62e61bb861eee306d5b069ce652b5aa5">Eigen::SparseMatrix::rows</a></div><div class="ttdeci">Index rows() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseMatrix_8h_source.html#l00136">SparseMatrix.h:136</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_acbede3f259186d48ad42ca093f80b64b"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#acbede3f259186d48ad42ca093f80b64b">Eigen::internal::SparseLUImpl::countnz</a></div><div class="ttdeci">void countnz(const Index n, Index &amp;nnzL, Index &amp;nnzU, GlobalLU_t &amp;glu)</div><div class="ttdoc">Count Nonzero elements in the factors.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__Utils_8h_source.html#l00021">SparseLU_Utils.h:21</a></div></div>
<div class="ttc" id="aclassEigen_1_1internal_1_1SparseLUImpl_html_acaf62fda387ea03e9caa2734e4e7b0c9"><div class="ttname"><a href="classEigen_1_1internal_1_1SparseLUImpl.html#acaf62fda387ea03e9caa2734e4e7b0c9">Eigen::internal::SparseLUImpl::panel_dfs</a></div><div class="ttdeci">void panel_dfs(const Index m, const Index w, const Index jcol, MatrixType &amp;A, IndexVector &amp;perm_r, Index &amp;nseg, ScalarVector &amp;dense, IndexVector &amp;panel_lsub, IndexVector &amp;segrep, IndexVector &amp;repfnz, IndexVector &amp;xprune, IndexVector &amp;marker, IndexVector &amp;parent, IndexVector &amp;xplore, GlobalLU_t &amp;glu)</div><div class="ttdoc">Performs a symbolic factorization on a panel of columns [jcol, jcol+w)</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU__panel__dfs_8h_source.html#l00219">SparseLU_panel_dfs.h:219</a></div></div>
<div class="ttc" id="aclassEigen_1_1PlainObjectBase_html_ac25699535374b1854cf8494e44ad31b2"><div class="ttname"><a href="classEigen_1_1PlainObjectBase.html#ac25699535374b1854cf8494e44ad31b2">Eigen::PlainObjectBase::data</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar * data() const</div><div class="ttdef"><b>Definition:</b> <a href="PlainObjectBase_8h_source.html#l00255">PlainObjectBase.h:255</a></div></div>
<div class="ttc" id="aclassEigen_1_1SparseLU_html_ab0d0c1744ffd5a1dff578a44bcef2a3d"><div class="ttname"><a href="classEigen_1_1SparseLU.html#ab0d0c1744ffd5a1dff578a44bcef2a3d">Eigen::SparseLU::info</a></div><div class="ttdeci">ComputationInfo info() const</div><div class="ttdoc">Reports whether previous computation was successful.</div><div class="ttdef"><b>Definition:</b> <a href="SparseLU_8h_source.html#l00202">SparseLU.h:202</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
