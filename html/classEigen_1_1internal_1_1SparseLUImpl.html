<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Baxter teleoperation project: Eigen::internal::SparseLUImpl&lt; Scalar, StorageIndex &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Baxter teleoperation project
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Documentation for the baxter teleoperation project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Eigen</b></li><li class="navelem"><b>internal</b></li><li class="navelem"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classEigen_1_1internal_1_1SparseLUImpl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::internal::SparseLUImpl&lt; Scalar, StorageIndex &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SparseLUImpl_8h_source.html">SparseLUImpl.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a26f9fb6f3223dad4b18a27f42c7db62e"><td class="memItemLeft" align="right" valign="top"><a id="a26f9fb6f3223dad4b18a27f42c7db62e"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:a26f9fb6f3223dad4b18a27f42c7db62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573839120675e129e912beac087d772"><td class="memItemLeft" align="right" valign="top"><a id="aa573839120675e129e912beac087d772"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; StorageIndex, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:aa573839120675e129e912beac087d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26e66444befb13e4b78de402e740fb1"><td class="memItemLeft" align="right" valign="top"><a id="aa26e66444befb13e4b78de402e740fb1"></a>
typedef <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, Dynamic, Dynamic, ColMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarMatrix</b></td></tr>
<tr class="separator:aa26e66444befb13e4b78de402e740fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4667303265643fcf2d28dbf7ae19b"><td class="memItemLeft" align="right" valign="top"><a id="a49d4667303265643fcf2d28dbf7ae19b"></a>
typedef <a class="el" href="classEigen_1_1Map.html">Map</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">ScalarMatrix</a>, 0, <a class="el" href="classEigen_1_1OuterStride.html">OuterStride</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MappedMatrixBlock</b></td></tr>
<tr class="separator:a49d4667303265643fcf2d28dbf7ae19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f0f7d4c248cdcde9290d861e5477c0"><td class="memItemLeft" align="right" valign="top"><a id="a59f0f7d4c248cdcde9290d861e5477c0"></a>
typedef ScalarVector::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:a59f0f7d4c248cdcde9290d861e5477c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7651c847b033fe45178cb2d987b98250"><td class="memItemLeft" align="right" valign="top"><a id="a7651c847b033fe45178cb2d987b98250"></a>
typedef <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; Scalar, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockScalarVector</b></td></tr>
<tr class="separator:a7651c847b033fe45178cb2d987b98250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152c34a81cb8401322bbff995b1267c"><td class="memItemLeft" align="right" valign="top"><a id="ab152c34a81cb8401322bbff995b1267c"></a>
typedef <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; StorageIndex, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlockIndexVector</b></td></tr>
<tr class="separator:ab152c34a81cb8401322bbff995b1267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0250f6ecd47c28d27aa30a0021ab0f91"><td class="memItemLeft" align="right" valign="top"><a id="a0250f6ecd47c28d27aa30a0021ab0f91"></a>
typedef <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">LU_GlobalLU_t</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a>, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalLU_t</b></td></tr>
<tr class="separator:a0250f6ecd47c28d27aa30a0021ab0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86851e5a5b59892aaee6a6404f303c8a"><td class="memItemLeft" align="right" valign="top"><a id="a86851e5a5b59892aaee6a6404f303c8a"></a>
typedef <a class="el" href="classEigen_1_1SparseMatrix.html">SparseMatrix</a>&lt; Scalar, ColMajor, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:a86851e5a5b59892aaee6a6404f303c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acc7811f7de19ffb804cb4b1fd5288f3e"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:acc7811f7de19ffb804cb4b1fd5288f3e"><td class="memTemplItemLeft" align="right" valign="top">Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#acc7811f7de19ffb804cb4b1fd5288f3e">expand</a> (VectorType &amp;vec, Index &amp;length, Index nbElts, Index keep_prev, Index &amp;num_expansions)</td></tr>
<tr class="separator:acc7811f7de19ffb804cb4b1fd5288f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018b8ed9664d4e19e34f1ff2d6c578a"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ac018b8ed9664d4e19e34f1ff2d6c578a">memInit</a> (Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ac018b8ed9664d4e19e34f1ff2d6c578a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate various working space for the numerical factorization phase.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#ac018b8ed9664d4e19e34f1ff2d6c578a">More...</a><br /></td></tr>
<tr class="separator:ac018b8ed9664d4e19e34f1ff2d6c578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6465f1173fd8b74b2e5b8ceec53343"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a2a6465f1173fd8b74b2e5b8ceec53343"><td class="memTemplItemLeft" align="right" valign="top">Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a2a6465f1173fd8b74b2e5b8ceec53343">memXpand</a> (VectorType &amp;vec, Index &amp;maxlen, Index nbElts, MemType memtype, Index &amp;num_expansions)</td></tr>
<tr class="memdesc:a2a6465f1173fd8b74b2e5b8ceec53343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the existing storage.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#a2a6465f1173fd8b74b2e5b8ceec53343">More...</a><br /></td></tr>
<tr class="separator:a2a6465f1173fd8b74b2e5b8ceec53343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88952ce33c968374b149e31d0539178d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a88952ce33c968374b149e31d0539178d">heap_relax_snode</a> (const Index n, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;et, const Index relax_columns, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;descendants, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;relax_end)</td></tr>
<tr class="memdesc:a88952ce33c968374b149e31d0539178d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the initial relaxed supernodes.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#a88952ce33c968374b149e31d0539178d">More...</a><br /></td></tr>
<tr class="separator:a88952ce33c968374b149e31d0539178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33672df380f94e774c5a6919d3474af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a33672df380f94e774c5a6919d3474af4">relax_snode</a> (const Index n, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;et, const Index relax_columns, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;descendants, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;relax_end)</td></tr>
<tr class="memdesc:a33672df380f94e774c5a6919d3474af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the initial relaxed supernodes.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#a33672df380f94e774c5a6919d3474af4">More...</a><br /></td></tr>
<tr class="separator:a33672df380f94e774c5a6919d3474af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5a4b5a17643e243e11741df018470"><td class="memItemLeft" align="right" valign="top"><a id="a75c5a4b5a17643e243e11741df018470"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>snode_dfs</b> (const Index jcol, const Index kcol, const <a class="el" href="classEigen_1_1SparseMatrix.html">MatrixType</a> &amp;mat, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;marker, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="separator:a75c5a4b5a17643e243e11741df018470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d835179cc3dcf09ff14ab3c8f0d9415"><td class="memItemLeft" align="right" valign="top"><a id="a2d835179cc3dcf09ff14ab3c8f0d9415"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>snode_bmod</b> (const Index jcol, const Index fsupc, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="separator:a2d835179cc3dcf09ff14ab3c8f0d9415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f56947465b829f8d523575724c3ac6"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ab5f56947465b829f8d523575724c3ac6">pivotL</a> (const Index jcol, const RealScalar &amp;diagpivotthresh, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;iperm_c, Index &amp;pivrow, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ab5f56947465b829f8d523575724c3ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the numerical pivotin on the current column of L, and the CDIV operation.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#ab5f56947465b829f8d523575724c3ac6">More...</a><br /></td></tr>
<tr class="separator:ab5f56947465b829f8d523575724c3ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef49b896c596d9e4893d3ae468d1dfac"><td class="memTemplParams" colspan="2"><a id="aef49b896c596d9e4893d3ae468d1dfac"></a>
template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:aef49b896c596d9e4893d3ae468d1dfac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dfs_kernel</b> (const StorageIndex jj, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, Index &amp;nseg, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;panel_lsub, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &gt; repfnz_col, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Ref.html">Ref</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &gt; marker, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;parent, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu, Index &amp;nextl_col, Index krow, Traits &amp;<a class="el" href="structEigen_1_1internal_1_1traits.html">traits</a>)</td></tr>
<tr class="separator:aef49b896c596d9e4893d3ae468d1dfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf62fda387ea03e9caa2734e4e7b0c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#acaf62fda387ea03e9caa2734e4e7b0c9">panel_dfs</a> (const Index m, const Index <a class="el" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>, const Index jcol, <a class="el" href="classEigen_1_1SparseMatrix.html">MatrixType</a> &amp;A, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, Index &amp;nseg, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;panel_lsub, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;marker, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;parent, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:acaf62fda387ea03e9caa2734e4e7b0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symbolic factorization on a panel of columns [jcol, jcol+w)  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#acaf62fda387ea03e9caa2734e4e7b0c9">More...</a><br /></td></tr>
<tr class="separator:acaf62fda387ea03e9caa2734e4e7b0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277936738db49e25285164ac25c498c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a277936738db49e25285164ac25c498c3">panel_bmod</a> (const Index m, const Index <a class="el" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>, const Index jcol, const Index nseg, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;dense, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;tempv, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;repfnz, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a277936738db49e25285164ac25c498c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-panel) in topological order.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#a277936738db49e25285164ac25c498c3">More...</a><br /></td></tr>
<tr class="separator:a277936738db49e25285164ac25c498c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f543ae02eb6467e9bcc1e5cec8ccdd2"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a6f543ae02eb6467e9bcc1e5cec8ccdd2">column_dfs</a> (const Index m, const Index jcol, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, Index maxsuper, Index &amp;nseg, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> lsub_col, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;marker, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;parent, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xplore, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a6f543ae02eb6467e9bcc1e5cec8ccdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symbolic factorization on column jcol and decide the supernode boundary.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#a6f543ae02eb6467e9bcc1e5cec8ccdd2">More...</a><br /></td></tr>
<tr class="separator:a6f543ae02eb6467e9bcc1e5cec8ccdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34275602cf12560edfcaf7cd5cbe932"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ae34275602cf12560edfcaf7cd5cbe932">column_bmod</a> (const Index jcol, const Index nseg, <a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a> dense, <a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;tempv, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, Index fpanelc, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ae34275602cf12560edfcaf7cd5cbe932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-col) in topological order.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#ae34275602cf12560edfcaf7cd5cbe932">More...</a><br /></td></tr>
<tr class="separator:ae34275602cf12560edfcaf7cd5cbe932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4867ed1d5f104f9245411c356416a21"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ae4867ed1d5f104f9245411c356416a21">copy_to_ucol</a> (const Index jcol, const Index nseg, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a> dense, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ae4867ed1d5f104f9245411c356416a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numeric block updates (sup-col) in topological order.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#ae4867ed1d5f104f9245411c356416a21">More...</a><br /></td></tr>
<tr class="separator:ae4867ed1d5f104f9245411c356416a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350464d1c83182fbd7da8a5a74bdfde8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#a350464d1c83182fbd7da8a5a74bdfde8">pruneL</a> (const Index jcol, const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, const Index pivrow, const Index nseg, const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;segrep, <a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a> repfnz, <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;xprune, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:a350464d1c83182fbd7da8a5a74bdfde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prunes the L-structure.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#a350464d1c83182fbd7da8a5a74bdfde8">More...</a><br /></td></tr>
<tr class="separator:a350464d1c83182fbd7da8a5a74bdfde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbede3f259186d48ad42ca093f80b64b"><td class="memItemLeft" align="right" valign="top"><a id="acbede3f259186d48ad42ca093f80b64b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#acbede3f259186d48ad42ca093f80b64b">countnz</a> (const Index n, Index &amp;nnzL, Index &amp;nnzU, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:acbede3f259186d48ad42ca093f80b64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count Nonzero elements in the factors. <br /></td></tr>
<tr class="separator:acbede3f259186d48ad42ca093f80b64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d1ed091956ff4e5734b4e3f79f866e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html#ae1d1ed091956ff4e5734b4e3f79f866e">fixupL</a> (const Index n, const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;perm_r, <a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;glu)</td></tr>
<tr class="memdesc:ae1d1ed091956ff4e5734b4e3f79f866e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix up the data storage lsub for L-subscripts.  <a href="classEigen_1_1internal_1_1SparseLUImpl.html#ae1d1ed091956ff4e5734b4e3f79f866e">More...</a><br /></td></tr>
<tr class="separator:ae1d1ed091956ff4e5734b4e3f79f866e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aeb52445d9b5f3ca9a6e74be2e7e42e12"><td class="memTemplParams" colspan="2"><a id="aeb52445d9b5f3ca9a6e74be2e7e42e12"></a>
template&lt;typename , typename &gt; </td></tr>
<tr class="memitem:aeb52445d9b5f3ca9a6e74be2e7e42e12"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>column_dfs_traits</b></td></tr>
<tr class="separator:aeb52445d9b5f3ca9a6e74be2e7e42e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, typename StorageIndex&gt;<br />
class Eigen::internal::SparseLUImpl&lt; Scalar, StorageIndex &gt;</h3>

<p>Base class for sparseLU </p>

<p class="definition">Definition at line <a class="el" href="SparseLUImpl_8h_source.html#l00020">20</a> of file <a class="el" href="SparseLUImpl_8h_source.html">SparseLUImpl.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae34275602cf12560edfcaf7cd5cbe932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34275602cf12560edfcaf7cd5cbe932">&#9670;&nbsp;</a></span>column_bmod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::column_bmod </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a>&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>fpanelc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs numeric block updates (sup-col) in topological order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jcol</td><td>current column to update </td></tr>
    <tr><td class="paramname">nseg</td><td>Number of segments in the U part </td></tr>
    <tr><td class="paramname">dense</td><td>Store the full representation of the column </td></tr>
    <tr><td class="paramname">tempv</td><td>working array </td></tr>
    <tr><td class="paramname">segrep</td><td>segment representative ... </td></tr>
    <tr><td class="paramname">repfnz</td><td>??? First nonzero column in each row ??? ... </td></tr>
    <tr><td class="paramname">fpanelc</td><td>First column in the current panel </td></tr>
    <tr><td class="paramname">glu</td><td>Global LU data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - successful return &gt; 0 - number of bytes allocated when run out of space </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__column__bmod_8h_source.html#l00053">53</a> of file <a class="el" href="SparseLU__column__bmod_8h_source.html">SparseLU_column_bmod.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  Index  jsupno, k, ksub, krep, ksupno; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  Index lptr, nrow, isub, irow, nextlu, new_next, ufirst; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  Index fsupc, nsupc, nsupr, luptr, kfnz, no_zeros; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">/* krep = representative of current k-th supernode</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">    * fsupc =  first supernodal column</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">    * nsupc = number of columns in a supernode</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">    * nsupr = number of rows in a supernode</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">    * luptr = location of supernodal LU-block in storage</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">    * kfnz = first nonz in the k-th supernodal segment</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">    * no_zeros = no lf leading zeros in a supernodal U-segment</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">    */</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  jsupno = glu.supno(jcol);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="comment">// For each nonzero supernode segment of U[*,j] in topological order </span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  k = nseg - 1; </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  Index d_fsupc; <span class="comment">// distance between the first column of the current panel and the </span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;               <span class="comment">// first column of the current snode</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  Index fst_col; <span class="comment">// First column within small LU update</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  Index segsize; </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">for</span> (ksub = 0; ksub &lt; nseg; ksub++)</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  {</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    krep = segrep(k); k--; </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    ksupno = glu.supno(krep); </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">if</span> (jsupno != ksupno )</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="comment">// outside the rectangular supernode </span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      fsupc = glu.xsup(ksupno); </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      fst_col = (std::max)(fsupc, fpanelc); </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      <span class="comment">// Distance from the current supernode to the current panel; </span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <span class="comment">// d_fsupc = 0 if fsupc &gt; fpanelc</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      d_fsupc = fst_col - fsupc; </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      luptr = glu.xlusup(fst_col) + d_fsupc; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      lptr = glu.xlsub(fsupc) + d_fsupc; </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;      kfnz = repfnz(krep); </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      kfnz = (std::max)(kfnz, fpanelc); </div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      segsize = krep - kfnz + 1; </div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      nsupc = krep - fst_col + 1; </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;      nsupr = glu.xlsub(fsupc+1) - glu.xlsub(fsupc); </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      nrow = nsupr - d_fsupc - nsupc;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      Index lda = glu.xlusup(fst_col+1) - glu.xlusup(fst_col);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      <span class="comment">// Perform a triangular solver and block update, </span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="comment">// then scatter the result of sup-col update to dense</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      no_zeros = kfnz - fst_col; </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="keywordflow">if</span>(segsize==1)</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        LU_kernel_bmod&lt;1&gt;::run(segsize, dense, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no_zeros);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        LU_kernel_bmod&lt;Dynamic&gt;::run(segsize, dense, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no_zeros);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    } <span class="comment">// end if jsupno </span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  } <span class="comment">// end for each segment</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="comment">// Process the supernodal portion of  L\U[*,j]</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  nextlu = glu.xlusup(jcol); </div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  fsupc = glu.xsup(jsupno);</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="comment">// copy the SPA dense into L\U[*,j]</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  Index mem; </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  new_next = nextlu + glu.xlsub(fsupc + 1) - glu.xlsub(fsupc); </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  Index offset = internal::first_multiple&lt;Index&gt;(new_next, internal::packet_traits&lt;Scalar&gt;::size) - new_next;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">if</span>(offset)</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    new_next += offset;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">while</span> (new_next &gt; glu.nzlumax )</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    mem = memXpand&lt;ScalarVector&gt;(glu.lusup, glu.nzlumax, nextlu, LUSUP, glu.num_expansions);  </div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">if</span> (mem) <span class="keywordflow">return</span> mem; </div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  }</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  </div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="keywordflow">for</span> (isub = glu.xlsub(fsupc); isub &lt; glu.xlsub(fsupc+1); isub++)</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  {</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    irow = glu.lsub(isub);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    glu.lusup(nextlu) = dense(irow);</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    dense(irow) = Scalar(0.0); </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    ++nextlu; </div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  }</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="keywordflow">if</span>(offset)</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    glu.lusup.segment(nextlu,offset).setZero();</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    nextlu += offset;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  glu.xlusup(jcol + 1) = StorageIndex(nextlu);  <span class="comment">// close L\U(*,jcol); </span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="comment">/* For more updates within the panel (also within the current supernode),</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">   * should start from the first column of the panel, or the first column</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">   * of the supernode, whichever is bigger. There are two cases:</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">   *  1) fsupc &lt; fpanelc, then fst_col &lt;-- fpanelc</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">   *  2) fsupc &gt;= fpanelc, then fst_col &lt;-- fsupc</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">   */</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  fst_col = (std::max)(fsupc, fpanelc); </div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="keywordflow">if</span> (fst_col  &lt; jcol)</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="comment">// Distance between the current supernode and the current panel</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="comment">// d_fsupc = 0 if fsupc &gt;= fpanelc</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    d_fsupc = fst_col - fsupc; </div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    </div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    lptr = glu.xlsub(fsupc) + d_fsupc; </div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    luptr = glu.xlusup(fst_col) + d_fsupc; </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    nsupr = glu.xlsub(fsupc+1) - glu.xlsub(fsupc); <span class="comment">// leading dimension</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    nsupc = jcol - fst_col; <span class="comment">// excluding jcol </span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    nrow = nsupr - d_fsupc - nsupc; </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="comment">// points to the beginning of jcol in snode L\U(jsupno) </span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    ufirst = glu.xlusup(jcol) + d_fsupc; </div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    Index lda = glu.xlusup(jcol+1) - glu.xlusup(jcol);</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    MappedMatrixBlock A( &amp;(glu.lusup.data()[luptr]), nsupc, nsupc, OuterStride&lt;&gt;(lda) );</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    VectorBlock&lt;ScalarVector&gt; u(glu.lusup, ufirst, nsupc); </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    u = A.template triangularView&lt;UnitLower&gt;().solve(u); </div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keyword">new</span> (&amp;A) MappedMatrixBlock ( &amp;(glu.lusup.data()[luptr+nsupc]), nrow, nsupc, OuterStride&lt;&gt;(lda) );</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    VectorBlock&lt;ScalarVector&gt; l(glu.lusup, ufirst+nsupc, nrow); </div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    l.noalias() -= A * u;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  } <span class="comment">// End if fst_col</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="keywordflow">return</span> 0; </div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f543ae02eb6467e9bcc1e5cec8ccdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f543ae02eb6467e9bcc1e5cec8ccdd2">&#9670;&nbsp;</a></span>column_dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::column_dfs </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>maxsuper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>lsub_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a symbolic factorization on column jcol and decide the supernode boundary. </p>
<p>A supernode representative is the last column of a supernode. The nonzeros in U[*,j] are segments that end at supernodes representatives. The routine returns a list of the supernodal representatives in topological order of the dfs that generates them. The location of the first nonzero in each supernodal segment (supernodal entry location) is also returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">jcol</td><td>Current column </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxsuper</td><td>Maximum number of column allowed in a supernode </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">nseg</td><td>Number of segments in current U[*,j] - new segments appended </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lsub_col</td><td>defines the rhs vector to start the dfs </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">segrep</td><td>Segment representatives - new segments appended </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">repfnz</td><td>First nonzero location in each row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xprune</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">marker</td><td>marker[i] == jj, if i was visited during dfs of current column jj; </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xplore</td><td>working array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>global LU data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success &gt; 0 number of bytes allocated when run out of space </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__column__dfs_8h_source.html#l00093">93</a> of file <a class="el" href="SparseLU__column__dfs_8h_source.html">SparseLU_column_dfs.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;{</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  Index jsuper = glu.supno(jcol); </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  Index nextl = glu.xlsub(jcol); </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  VectorBlock&lt;IndexVector&gt; marker2(marker, 2*m, m); </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  column_dfs_traits&lt;IndexVector, ScalarVector&gt; traits(jcol, jsuper, glu, *<span class="keyword">this</span>);</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="comment">// For each nonzero in A(*,jcol) do dfs </span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="keywordflow">for</span> (Index k = 0; ((k &lt; m) ? lsub_col[k] != emptyIdxLU : <span class="keyword">false</span>) ; k++)</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    Index krow = lsub_col(k); </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    lsub_col(k) = emptyIdxLU; </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    Index kmark = marker2(krow); </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="comment">// krow was visited before, go to the next nonz; </span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">if</span> (kmark == jcol) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    dfs_kernel(StorageIndex(jcol), perm_r, nseg, glu.lsub, segrep, repfnz, xprune, marker2, parent,</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                   xplore, glu, nextl, krow, traits);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  } <span class="comment">// for each nonzero ... </span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  Index fsupc;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  StorageIndex nsuper = glu.supno(jcol);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  StorageIndex jcolp1 = StorageIndex(jcol) + 1;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  Index jcolm1 = jcol - 1;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="comment">// check to see if j belongs in the same supernode as j-1</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordflow">if</span> ( jcol == 0 )</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  { <span class="comment">// Do nothing for column 0 </span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    nsuper = glu.supno(0) = 0 ;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  {</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    fsupc = glu.xsup(nsuper); </div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    StorageIndex jptr = glu.xlsub(jcol); <span class="comment">// Not yet compressed</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    StorageIndex jm1ptr = glu.xlsub(jcolm1); </div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    </div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    <span class="comment">// Use supernodes of type T2 : see SuperLU paper</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">if</span> ( (nextl-jptr != jptr-jm1ptr-1) ) jsuper = emptyIdxLU;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    </div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="comment">// Make sure the number of columns in a supernode doesn&#39;t</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="comment">// exceed threshold</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">if</span> ( (jcol - fsupc) &gt;= maxsuper) jsuper = emptyIdxLU; </div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    </div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="comment">/* If jcol starts a new supernode, reclaim storage space in</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">     * glu.lsub from previous supernode. Note we only store </span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">     * the subscript set of the first and last columns of </span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment">     * a supernode. (first for num values, last for pruning)</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">if</span> (jsuper == emptyIdxLU)</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    { <span class="comment">// starts a new supernode </span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      <span class="keywordflow">if</span> ( (fsupc &lt; jcolm1-1) ) </div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      { <span class="comment">// &gt;= 3 columns in nsuper</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        StorageIndex ito = glu.xlsub(fsupc+1);</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        glu.xlsub(jcolm1) = ito; </div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        StorageIndex istop = ito + jptr - jm1ptr; </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        xprune(jcolm1) = istop; <span class="comment">// intialize xprune(jcol-1)</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        glu.xlsub(jcol) = istop; </div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        </div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="keywordflow">for</span> (StorageIndex ifrom = jm1ptr; ifrom &lt; nextl; ++ifrom, ++ito)</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;          glu.lsub(ito) = glu.lsub(ifrom); </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        nextl = ito;  <span class="comment">// = istop + length(jcol)</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      }</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;      nsuper++; </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      glu.supno(jcol) = nsuper; </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    } <span class="comment">// if a new supernode </span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  } <span class="comment">// end else:  jcol &gt; 0</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="comment">// Tidy up the pointers before exit</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  glu.xsup(nsuper+1) = jcolp1; </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  glu.supno(jcolp1) = nsuper; </div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  xprune(jcol) = StorageIndex(nextl);  <span class="comment">// Intialize upper bound for pruning</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  glu.xlsub(jcolp1) = StorageIndex(nextl); </div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  </div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keywordflow">return</span> 0; </div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4867ed1d5f104f9245411c356416a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4867ed1d5f104f9245411c356416a21">&#9670;&nbsp;</a></span>copy_to_ucol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::copy_to_ucol </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockScalarVector</a>&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs numeric block updates (sup-col) in topological order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jcol</td><td>current column to update </td></tr>
    <tr><td class="paramname">nseg</td><td>Number of segments in the U part </td></tr>
    <tr><td class="paramname">segrep</td><td>segment representative ... </td></tr>
    <tr><td class="paramname">repfnz</td><td>First nonzero column in each row ... </td></tr>
    <tr><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramname">dense</td><td>Store the full representation of the column </td></tr>
    <tr><td class="paramname">glu</td><td>Global LU data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - successful return &gt; 0 - number of bytes allocated when run out of space </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__copy__to__ucol_8h_source.html#l00050">50</a> of file <a class="el" href="SparseLU__copy__to__ucol_8h_source.html">SparseLU_copy_to_ucol.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;{  </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  Index ksub, krep, ksupno; </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  Index jsupno = glu.supno(jcol);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="comment">// For each nonzero supernode segment of U[*,j] in topological order </span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  Index k = nseg - 1, i; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  StorageIndex nextu = glu.xusub(jcol); </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  Index kfnz, isub, segsize; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  Index new_next,irow; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  Index fsupc, mem; </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="keywordflow">for</span> (ksub = 0; ksub &lt; nseg; ksub++)</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    krep = segrep(k); k--; </div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    ksupno = glu.supno(krep); </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">if</span> (jsupno != ksupno ) <span class="comment">// should go into ucol(); </span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    {</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      kfnz = repfnz(krep); </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      <span class="keywordflow">if</span> (kfnz != emptyIdxLU)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      { <span class="comment">// Nonzero U-segment </span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        fsupc = glu.xsup(ksupno); </div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        isub = glu.xlsub(fsupc) + kfnz - fsupc; </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        segsize = krep - kfnz + 1; </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        new_next = nextu + segsize; </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordflow">while</span> (new_next &gt; glu.nzumax) </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;          mem = memXpand&lt;ScalarVector&gt;(glu.ucol, glu.nzumax, nextu, UCOL, glu.num_expansions); </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;          <span class="keywordflow">if</span> (mem) <span class="keywordflow">return</span> mem; </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;          mem = memXpand&lt;IndexVector&gt;(glu.usub, glu.nzumax, nextu, USUB, glu.num_expansions); </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;          <span class="keywordflow">if</span> (mem) <span class="keywordflow">return</span> mem; </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;          </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; segsize; i++)</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;          irow = glu.lsub(isub); </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;          glu.usub(nextu) = perm_r(irow); <span class="comment">// Unlike the L part, the U part is stored in its final order</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;          glu.ucol(nextu) = dense(irow); </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;          dense(irow) = Scalar(0.0); </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;          nextu++;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;          isub++;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      } <span class="comment">// end nonzero U-segment </span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    } <span class="comment">// end if jsupno </span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  } <span class="comment">// end for each segment</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  glu.xusub(jcol + 1) = nextu; <span class="comment">// close U(*,jcol)</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">return</span> 0; </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acc7811f7de19ffb804cb4b1fd5288f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7811f7de19ffb804cb4b1fd5288f3e">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::expand </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nbElts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>keep_prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>num_expansions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expand the existing storage to accomodate more fill-ins </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vec</td><td>Valid pointer to the vector to allocate or expand </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">length</td><td>At input, contain the current length of the vector that is to be increased. At output, length of the newly allocated vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbElts</td><td>Current number of elements in the factors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keep_prev</td><td>1: use length and do not expand the vector; 0: compute new_len and expand </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">num_expansions</td><td>Number of times the memory has been expanded </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__Memory_8h_source.html#l00063">63</a> of file <a class="el" href="SparseLU__Memory_8h_source.html">SparseLU_Memory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  </div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <span class="keywordtype">float</span> alpha = 1.5; <span class="comment">// Ratio of the memory increase </span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  Index new_len; <span class="comment">// New size of the allocated memory</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keywordflow">if</span>(num_expansions == 0 || keep_prev) </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    new_len = length ; <span class="comment">// First time allocate requested</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    new_len = (std::max)(length+1,Index(alpha * length));</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  VectorType old_vec; <span class="comment">// Temporary vector to hold the previous values   </span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="keywordflow">if</span> (nbElts &gt; 0 )</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    old_vec = vec.segment(0,nbElts); </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <span class="comment">//Allocate or expand the current vector</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="preprocessor">#ifdef EIGEN_EXCEPTIONS</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="keywordflow">try</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    vec.resize(new_len); </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  }</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="preprocessor">#ifdef EIGEN_EXCEPTIONS</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="keywordflow">catch</span>(std::bad_alloc&amp; )</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordflow">if</span>(!vec.size())</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;#endif</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">if</span> (!num_expansions)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      <span class="comment">// First time to allocate from LUMemInit()</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="comment">// Let LUMemInit() deals with it.</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      <span class="keywordflow">return</span> -1;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordflow">if</span> (keep_prev)</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      <span class="comment">// In this case, the memory length should not not be reduced</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      <span class="keywordflow">return</span> new_len;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      <span class="comment">// Reduce the size and increase again </span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      Index tries = 0; <span class="comment">// Number of attempts</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      <span class="keywordflow">do</span> </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        alpha = (alpha + 1)/2;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        new_len = (std::max)(length+1,Index(alpha * length));</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="preprocessor">#ifdef EIGEN_EXCEPTIONS</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">try</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        {</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;          vec.resize(new_len); </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        }</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="preprocessor">#ifdef EIGEN_EXCEPTIONS</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keywordflow">catch</span>(std::bad_alloc&amp; )</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">if</span> (!vec.size())</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;#endif</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;          tries += 1; </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          <span class="keywordflow">if</span> ( tries &gt; 10) <span class="keywordflow">return</span> new_len; </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        }</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      } <span class="keywordflow">while</span> (!vec.size());</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    }</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  }</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="comment">//Copy the previous values to the newly allocated space </span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="keywordflow">if</span> (nbElts &gt; 0)</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    vec.segment(0, nbElts) = old_vec;   </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;   </div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  length  = new_len;</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  <span class="keywordflow">if</span>(num_expansions) ++num_expansions;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <span class="keywordflow">return</span> 0; </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae1d1ed091956ff4e5734b4e3f79f866e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d1ed091956ff4e5734b4e3f79f866e">&#9670;&nbsp;</a></span>fixupL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::fixupL </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix up the data storage lsub for L-subscripts. </p>
<p>It removes the subscripts sets for structural pruning, and applies permutation to the remaining subscripts </p>

<p class="definition">Definition at line <a class="el" href="SparseLU__Utils_8h_source.html#l00052">52</a> of file <a class="el" href="SparseLU__Utils_8h_source.html">SparseLU_Utils.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;{</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  Index fsupc, i, j, k, jstart; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  StorageIndex nextl = 0; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  Index nsuper = (glu.supno)(n); </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// For each supernode </span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordflow">for</span> (i = 0; i &lt;= nsuper; i++)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  {</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    fsupc = glu.xsup(i); </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    jstart = glu.xlsub(fsupc); </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    glu.xlsub(fsupc) = nextl; </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">for</span> (j = jstart; j &lt; glu.xlsub(fsupc + 1); j++)</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      glu.lsub(nextl) = perm_r(glu.lsub(j)); <span class="comment">// Now indexed into P*A</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      nextl++;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    }</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">for</span> (k = fsupc+1; k &lt; glu.xsup(i+1); k++)</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      glu.xlsub(k) = nextl; <span class="comment">// other columns in supernode i</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  }</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  glu.xlsub(n) = nextl; </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a88952ce33c968374b149e31d0539178d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88952ce33c968374b149e31d0539178d">&#9670;&nbsp;</a></span>heap_relax_snode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::heap_relax_snode </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>relax_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>relax_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify the initial relaxed supernodes. </p>
<p>This routine applied to a symmetric elimination tree. It assumes that the matrix has been reordered according to the postorder of the etree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of columns </td></tr>
    <tr><td class="paramname">et</td><td>elimination tree </td></tr>
    <tr><td class="paramname">relax_columns</td><td>Maximum number of columns allowed in a relaxed snode </td></tr>
    <tr><td class="paramname">descendants</td><td>Number of descendants of each node in the etree </td></tr>
    <tr><td class="paramname">relax_end</td><td>last column in a supernode </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__heap__relax__snode_8h_source.html#l00046">46</a> of file <a class="el" href="SparseLU__heap__relax__snode_8h_source.html">SparseLU_heap_relax_snode.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;{</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="comment">// The etree may not be postordered, but its heap ordered  </span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  IndexVector post;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  internal::treePostorder(StorageIndex(n), et, post); <span class="comment">// Post order etree</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  IndexVector inv_post(n+1); </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="keywordflow">for</span> (StorageIndex i = 0; i &lt; n+1; ++i) inv_post(post(i)) = i; <span class="comment">// inv_post = post.inverse()???</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// Renumber etree in postorder </span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  IndexVector iwork(n);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  IndexVector et_save(n+1);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="keywordflow">for</span> (Index i = 0; i &lt; n; ++i)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  {</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    iwork(post(i)) = post(et(i));</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  }</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  et_save = et; <span class="comment">// Save the original etree</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  et = iwork; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  <span class="comment">// compute the number of descendants of each node in the etree</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  relax_end.setConstant(emptyIdxLU);</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  Index j, parent; </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  descendants.setZero();</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    parent = et(j);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">if</span> (parent != n) <span class="comment">// not the dummy root</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;      descendants(parent) += descendants(j) + 1;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  }</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  <span class="comment">// Identify the relaxed supernodes by postorder traversal of the etree</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  Index snode_start; <span class="comment">// beginning of a snode </span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  StorageIndex k;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  Index nsuper_et_post = 0; <span class="comment">// Number of relaxed snodes in postordered etree </span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  Index nsuper_et = 0; <span class="comment">// Number of relaxed snodes in the original etree </span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  StorageIndex l; </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  <span class="keywordflow">for</span> (j = 0; j &lt; n; )</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    parent = et(j);</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    snode_start = j; </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keywordflow">while</span> ( parent != n &amp;&amp; descendants(parent) &lt; relax_columns ) </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      j = parent; </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      parent = et(j);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    }</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">// Found a supernode in postordered etree, j is the last column </span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    ++nsuper_et_post;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    k = StorageIndex(n);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">for</span> (Index i = snode_start; i &lt;= j; ++i)</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      k = (std::min)(k, inv_post(i));</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    l = inv_post(j);</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">if</span> ( (l - k) == (j - snode_start) )  <span class="comment">// Same number of columns in the snode</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      <span class="comment">// This is also a supernode in the original etree</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      relax_end(k) = l; <span class="comment">// Record last column </span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      ++nsuper_et; </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      <span class="keywordflow">for</span> (Index i = snode_start; i &lt;= j; ++i) </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        l = inv_post(i);</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="keywordflow">if</span> (descendants(i) == 0) </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;          relax_end(l) = l;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;          ++nsuper_et;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;      }</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    j++;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="comment">// Search for a new leaf</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keywordflow">while</span> (descendants(j) != 0 &amp;&amp; j &lt; n) j++;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  } <span class="comment">// End postorder traversal of the etree</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// Recover the original etree</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  et = et_save; </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac018b8ed9664d4e19e34f1ff2d6c578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac018b8ed9664d4e19e34f1ff2d6c578a">&#9670;&nbsp;</a></span>memInit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::memInit </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>annz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>lwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>fillratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>panel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate various working space for the numerical factorization phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>number of rows of the input matrix </td></tr>
    <tr><td class="paramname">n</td><td>number of columns </td></tr>
    <tr><td class="paramname">annz</td><td>number of initial nonzeros in the matrix </td></tr>
    <tr><td class="paramname">lwork</td><td>if lwork=-1, this routine returns an estimated size of the required memory </td></tr>
    <tr><td class="paramname">glu</td><td>persistent data to facilitate multiple factors : will be deleted later ?? </td></tr>
    <tr><td class="paramname">fillratio</td><td>estimated ratio of fill in the factors </td></tr>
    <tr><td class="paramname">panel_size</td><td>Size of a panel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimated size of the required memory if lwork = -1; otherwise, return the size of actually allocated memory when allocation failed, and 0 on success </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="classEigen_1_1SuperLU.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a>, this routine does not support successive factorization with the same pattern and the same row permutation </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__Memory_8h_source.html#l00151">151</a> of file <a class="el" href="SparseLU__Memory_8h_source.html">SparseLU_Memory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;{</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  Index&amp; num_expansions = glu.num_expansions; <span class="comment">//No memory expansions so far</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  num_expansions = 0;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  glu.nzumax = glu.nzlumax = (std::min)(fillratio * (annz+1) / n, m) * n; <span class="comment">// estimated number of nonzeros in U </span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  glu.nzlmax = (std::max)(Index(4), fillratio) * (annz+1) / 4; <span class="comment">// estimated  nnz in L factor</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  <span class="comment">// Return the estimated size to the user if necessary</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  Index tempSpace;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  tempSpace = (2*panel_size + 4 + LUNoMarker) * m * <span class="keyword">sizeof</span>(Index) + (panel_size + 1) * m * <span class="keyword">sizeof</span>(Scalar);</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  <span class="keywordflow">if</span> (lwork == emptyIdxLU) </div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    Index estimated_size;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    estimated_size = (5 * n + 5) * <span class="keyword">sizeof</span>(Index)  + tempSpace</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                    + (glu.nzlmax + glu.nzumax) * <span class="keyword">sizeof</span>(Index) + (glu.nzlumax+glu.nzumax) *  <span class="keyword">sizeof</span>(Scalar) + n; </div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keywordflow">return</span> estimated_size;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="comment">// Setup the required space </span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="comment">// First allocate Integer pointers for L\U factors</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  glu.xsup.resize(n+1);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  glu.supno.resize(n+1);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  glu.xlsub.resize(n+1);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  glu.xlusup.resize(n+1);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  glu.xusub.resize(n+1);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160; </div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">// Reserve memory for L/U factors</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordflow">do</span> </div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  {</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">if</span>(     (expand&lt;ScalarVector&gt;(glu.lusup, glu.nzlumax, 0, 0, num_expansions)&lt;0)</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        ||  (expand&lt;ScalarVector&gt;(glu.ucol,  glu.nzumax,  0, 0, num_expansions)&lt;0)</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        ||  (expand&lt;IndexVector&gt; (glu.lsub,  glu.nzlmax,  0, 0, num_expansions)&lt;0)</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        ||  (expand&lt;IndexVector&gt; (glu.usub,  glu.nzumax,  0, 1, num_expansions)&lt;0) )</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      <span class="comment">//Reduce the estimated size and retry</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      glu.nzlumax /= 2;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      glu.nzumax /= 2;</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      glu.nzlmax /= 2;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;      <span class="keywordflow">if</span> (glu.nzlumax &lt; annz ) <span class="keywordflow">return</span> glu.nzlumax; </div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  } <span class="keywordflow">while</span> (!glu.lusup.size() || !glu.ucol.size() || !glu.lsub.size() || !glu.usub.size());</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  ++num_expansions;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  </div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;} <span class="comment">// end LuMemInit</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a6465f1173fd8b74b2e5b8ceec53343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6465f1173fd8b74b2e5b8ceec53343">&#9670;&nbsp;</a></span>memXpand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::memXpand </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>maxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nbElts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemType&#160;</td>
          <td class="paramname"><em>memtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>num_expansions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the existing storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vec</td><td>vector to expand </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxlen</td><td>On input, previous size of vec (Number of elements to copy ). on output, new size </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nbElts</td><td>current number of elements in the vector. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memtype</td><td>Type of the element to expand </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num_expansions</td><td>Number of expansions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &gt; 0 size of the memory allocated so far </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__Memory_8h_source.html#l00209">209</a> of file <a class="el" href="SparseLU__Memory_8h_source.html">SparseLU_Memory.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;{</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  Index failed_size; </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="keywordflow">if</span> (memtype == USUB)</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;     failed_size = this-&gt;expand&lt;VectorType&gt;(vec, maxlen, nbElts, 1, num_expansions);</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    failed_size = this-&gt;expand&lt;VectorType&gt;(vec, maxlen, nbElts, 0, num_expansions);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160; </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keywordflow">if</span> (failed_size)</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordflow">return</span> failed_size; </div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  </div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  <span class="keywordflow">return</span> 0 ;  </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a277936738db49e25285164ac25c498c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277936738db49e25285164ac25c498c3">&#9670;&nbsp;</a></span>panel_bmod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::panel_bmod </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>tempv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs numeric block updates (sup-panel) in topological order. </p>
<p>Before entering this routine, the original nonzeros in the panel were already copied i nto the spa[m,w]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">w</td><td>Panel size </td></tr>
    <tr><td class="paramname">jcol</td><td>Starting column of the panel </td></tr>
    <tr><td class="paramname">nseg</td><td>Number of segments in the U part </td></tr>
    <tr><td class="paramname">dense</td><td>Store the full representation of the panel </td></tr>
    <tr><td class="paramname">tempv</td><td>working array </td></tr>
    <tr><td class="paramname">segrep</td><td>segment representative... first row in the segment </td></tr>
    <tr><td class="paramname">repfnz</td><td>First nonzero rows </td></tr>
    <tr><td class="paramname">glu</td><td>Global LU data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__panel__bmod_8h_source.html#l00056">56</a> of file <a class="el" href="SparseLU__panel__bmod_8h_source.html">SparseLU_panel_bmod.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;{</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  Index ksub,jj,nextl_col; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  Index fsupc, nsupc, nsupr, nrow; </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  Index krep, kfnz; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  Index lptr; <span class="comment">// points to the row subscripts of a supernode </span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  Index luptr; <span class="comment">// ...</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  Index segsize,no_zeros ; </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="comment">// For each nonz supernode segment of U[*,j] in topological order</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  Index k = nseg - 1; </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keyword">const</span> Index PacketSize = internal::packet_traits&lt;Scalar&gt;::size;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordflow">for</span> (ksub = 0; ksub &lt; nseg; ksub++)</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  { <span class="comment">// For each updating supernode</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">/* krep = representative of current k-th supernode</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">     * fsupc =  first supernodal column</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">     * nsupc = number of columns in a supernode</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">     * nsupr = number of rows in a supernode</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">     */</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    krep = segrep(k); k--; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    fsupc = glu.xsup(glu.supno(krep)); </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    nsupc = krep - fsupc + 1; </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    nsupr = glu.xlsub(fsupc+1) - glu.xlsub(fsupc); </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    nrow = nsupr - nsupc; </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    lptr = glu.xlsub(fsupc); </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="comment">// loop over the panel columns to detect the actual number of columns and rows</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    Index u_rows = 0;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    Index u_cols = 0;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">for</span> (jj = jcol; jj &lt; jcol + <a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>; jj++)</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    {</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      nextl_col = (jj-jcol) * m; </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      VectorBlock&lt;IndexVector&gt; repfnz_col(repfnz, nextl_col, m); <span class="comment">// First nonzero column index for each row</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;      </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      kfnz = repfnz_col(krep); </div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordflow">if</span> ( kfnz == emptyIdxLU ) </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="keywordflow">continue</span>; <span class="comment">// skip any zero segment</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;      segsize = krep - kfnz + 1;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      u_cols++;</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      u_rows = (std::max)(segsize,u_rows);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    }</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span>(nsupc &gt;= 2)</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    { </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      Index ldu = internal::first_multiple&lt;Index&gt;(u_rows, PacketSize);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      Map&lt;ScalarMatrix, Aligned,  OuterStride&lt;&gt; &gt; U(tempv.data(), u_rows, u_cols, OuterStride&lt;&gt;(ldu));</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <span class="comment">// gather U</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      Index u_col = 0;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      <span class="keywordflow">for</span> (jj = jcol; jj &lt; jcol + <a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>; jj++)</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        nextl_col = (jj-jcol) * m; </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        VectorBlock&lt;IndexVector&gt; repfnz_col(repfnz, nextl_col, m); <span class="comment">// First nonzero column index for each row</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        VectorBlock&lt;ScalarVector&gt; dense_col(dense, nextl_col, m); <span class="comment">// Scatter/gather entire matrix column from/to here</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        kfnz = repfnz_col(krep); </div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">if</span> ( kfnz == emptyIdxLU ) </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;          <span class="keywordflow">continue</span>; <span class="comment">// skip any zero segment</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        segsize = krep - kfnz + 1;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        luptr = glu.xlusup(fsupc);    </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        no_zeros = kfnz - fsupc; </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        Index isub = lptr + no_zeros;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        Index off = u_rows-segsize;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keywordflow">for</span> (Index i = 0; i &lt; off; i++) U(i,u_col) = 0;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">for</span> (Index i = 0; i &lt; segsize; i++)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          Index irow = glu.lsub(isub); </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;          U(i+off,u_col) = dense_col(irow); </div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;          ++isub; </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        u_col++;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;      }</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      <span class="comment">// solve U = A^-1 U</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;      luptr = glu.xlusup(fsupc);</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;      Index lda = glu.xlusup(fsupc+1) - glu.xlusup(fsupc);</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;      no_zeros = (krep - u_rows + 1) - fsupc;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      luptr += lda * no_zeros + no_zeros;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      MappedMatrixBlock A(glu.lusup.data()+luptr, u_rows, u_rows, OuterStride&lt;&gt;(lda) );</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;      U = A.template triangularView&lt;UnitLower&gt;().solve(U);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      </div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;      <span class="comment">// update</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;      luptr += u_rows;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      MappedMatrixBlock B(glu.lusup.data()+luptr, nrow, u_rows, OuterStride&lt;&gt;(lda) );</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      eigen_assert(tempv.size()&gt;<a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>*ldu + nrow*<a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a> + 1);</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;      </div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      Index ldl = internal::first_multiple&lt;Index&gt;(nrow, PacketSize);</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;      Index offset = (PacketSize-internal::first_default_aligned(B.data(), PacketSize)) % PacketSize;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      MappedMatrixBlock L(tempv.data()+<a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>*ldu+offset, nrow, u_cols, OuterStride&lt;&gt;(ldl));</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      </div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      L.setZero();</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      internal::sparselu_gemm&lt;Scalar&gt;(L.rows(), L.cols(), B.cols(), B.data(), B.outerStride(), U.data(), U.outerStride(), L.data(), L.outerStride());</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;      <span class="comment">// scatter U and L</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      u_col = 0;</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      <span class="keywordflow">for</span> (jj = jcol; jj &lt; jcol + <a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>; jj++)</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;        nextl_col = (jj-jcol) * m; </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        VectorBlock&lt;IndexVector&gt; repfnz_col(repfnz, nextl_col, m); <span class="comment">// First nonzero column index for each row</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        VectorBlock&lt;ScalarVector&gt; dense_col(dense, nextl_col, m); <span class="comment">// Scatter/gather entire matrix column from/to here</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        kfnz = repfnz_col(krep); </div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">if</span> ( kfnz == emptyIdxLU ) </div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;          <span class="keywordflow">continue</span>; <span class="comment">// skip any zero segment</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        </div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        segsize = krep - kfnz + 1;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        no_zeros = kfnz - fsupc; </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        Index isub = lptr + no_zeros;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        Index off = u_rows-segsize;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">for</span> (Index i = 0; i &lt; segsize; i++)</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;          Index irow = glu.lsub(isub++); </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;          dense_col(irow) = U.coeff(i+off,u_col);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;          U.coeffRef(i+off,u_col) = 0;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="comment">// Scatter l into SPA dense[]</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        <span class="keywordflow">for</span> (Index i = 0; i &lt; nrow; i++)</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        {</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;          Index irow = glu.lsub(isub++); </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;          dense_col(irow) -= L.coeff(i,u_col);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;          L.coeffRef(i,u_col) = 0;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        }</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        u_col++;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      }</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordflow">else</span> <span class="comment">// level 2 only</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    {</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;      <span class="comment">// Sequence through each column in the panel</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;      <span class="keywordflow">for</span> (jj = jcol; jj &lt; jcol + <a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>; jj++)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        nextl_col = (jj-jcol) * m; </div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        VectorBlock&lt;IndexVector&gt; repfnz_col(repfnz, nextl_col, m); <span class="comment">// First nonzero column index for each row</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        VectorBlock&lt;ScalarVector&gt; dense_col(dense, nextl_col, m); <span class="comment">// Scatter/gather entire matrix column from/to here</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        </div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        kfnz = repfnz_col(krep); </div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">if</span> ( kfnz == emptyIdxLU ) </div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;          <span class="keywordflow">continue</span>; <span class="comment">// skip any zero segment</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        </div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        segsize = krep - kfnz + 1;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        luptr = glu.xlusup(fsupc);</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        Index lda = glu.xlusup(fsupc+1)-glu.xlusup(fsupc);<span class="comment">// nsupr</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        </div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="comment">// Perform a trianglar solve and block update, </span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="comment">// then scatter the result of sup-col update to dense[]</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        no_zeros = kfnz - fsupc; </div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;              <span class="keywordflow">if</span>(segsize==1)  LU_kernel_bmod&lt;1&gt;::run(segsize, dense_col, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no_zeros);</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="keywordflow">else</span>  <span class="keywordflow">if</span>(segsize==2)  LU_kernel_bmod&lt;2&gt;::run(segsize, dense_col, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no_zeros);</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <span class="keywordflow">else</span>  <span class="keywordflow">if</span>(segsize==3)  LU_kernel_bmod&lt;3&gt;::run(segsize, dense_col, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no_zeros);</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">else</span>                  LU_kernel_bmod&lt;Dynamic&gt;::run(segsize, dense_col, tempv, glu.lusup, luptr, lda, nrow, glu.lsub, lptr, no_zeros); </div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      } <span class="comment">// End for each column in the panel </span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    }</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  } <span class="comment">// End for each updating supernode</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;} <span class="comment">// end panel bmod</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acaf62fda387ea03e9caa2734e4e7b0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf62fda387ea03e9caa2734e4e7b0c9">&#9670;&nbsp;</a></span>panel_dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::panel_dfs </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1SparseMatrix.html">MatrixType</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">ScalarVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>panel_lsub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xplore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a symbolic factorization on a panel of columns [jcol, jcol+w) </p>
<p>A supernode representative is the last column of a supernode. The nonzeros in U[*,j] are segments that end at supernodes representatives</p>
<p>The routine returns a list of the supernodal representatives in topological order of the dfs that generates them. This list is a superset of the topological order of each individual column within the panel. The location of the first nonzero in each supernodal segment (supernodal entry location) is also returned. Each column has a separate list for this purpose.</p>
<p>Two markers arrays are used for dfs : marker[i] == jj, if i was visited during dfs of current column jj; marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Panel size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jcol</td><td>Starting column of the panel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix in column-major storage </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nseg</td><td>Number of U segments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dense</td><td>Accumulate the column vectors of the panel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">panel_lsub</td><td>Subscripts of the row in the panel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segrep</td><td>Segment representative i.e first nonzero row of each segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">repfnz</td><td>First nonzero location in each row </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xprune</td><td>The pruned elimination tree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">marker</td><td>work vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>The elimination tree </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">xplore</td><td>work vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>The global data structure </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__panel__dfs_8h_source.html#l00219">219</a> of file <a class="el" href="SparseLU__panel__dfs_8h_source.html">SparseLU_panel_dfs.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;{</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  Index nextl_col; <span class="comment">// Next available position in panel_lsub[*,jj] </span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  </div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="comment">// Initialize pointers </span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  VectorBlock&lt;IndexVector&gt; marker1(marker, m, m); </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  nseg = 0; </div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  </div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  panel_dfs_traits&lt;IndexVector&gt; traits(jcol, marker1.data());</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  </div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="comment">// For each column in the panel </span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="keywordflow">for</span> (StorageIndex jj = StorageIndex(jcol); jj &lt; jcol + <a class="code" href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a>; jj++) </div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    nextl_col = (jj - jcol) * m; </div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    </div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    VectorBlock&lt;IndexVector&gt; repfnz_col(repfnz, nextl_col, m); <span class="comment">// First nonzero location in each row</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    VectorBlock&lt;ScalarVector&gt; dense_col(dense,nextl_col, m); <span class="comment">// Accumulate a column vector here</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    </div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    </div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="comment">// For each nnz in A[*, jj] do depth first search</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">typename</span> MatrixType::InnerIterator it(A, jj); it; ++it)</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    {</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;      Index krow = it.row(); </div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;      dense_col(krow) = it.value();</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      </div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      StorageIndex kmark = marker(krow); </div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;      <span class="keywordflow">if</span> (kmark == jj) </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordflow">continue</span>; <span class="comment">// krow visited before, go to the next nonzero</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      dfs_kernel(jj, perm_r, nseg, panel_lsub, segrep, repfnz_col, xprune, marker, parent,</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                   xplore, glu, nextl_col, krow, traits);</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    }<span class="comment">// end for nonzeros in column jj</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    </div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  } <span class="comment">// end for column jj</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5f56947465b829f8d523575724c3ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f56947465b829f8d523575724c3ac6">&#9670;&nbsp;</a></span>pivotL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::pivotL </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>diagpivotthresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>iperm_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the numerical pivotin on the current column of L, and the CDIV operation. </p>
<p>Pivot policy : (1) Compute thresh = u * max_(i&gt;=j) abs(A_ij); (2) IF user specifies pivot row k and abs(A_kj) &gt;= thresh THEN pivot row = k; ELSE IF abs(A_jj) &gt;= thresh THEN pivot row = j; ELSE pivot row = m;</p>
<p>Note: If you absolutely want to use a given pivot order, then set u=0.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">jcol</td><td>The current column of L </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">diagpivotthresh</td><td>diagonal pivoting threshold </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">perm_r</td><td>Row permutation (threshold pivoting) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iperm_c</td><td>column permutation - used to finf diagonal of Pc*A*Pc' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pivrow</td><td>The pivot row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>Global LU data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, i &gt; 0 if U(i,i) is exactly zero </dd></dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__pivotL_8h_source.html#l00060">60</a> of file <a class="el" href="SparseLU__pivotL_8h_source.html">SparseLU_pivotL.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  Index fsupc = (glu.xsup)((glu.supno)(jcol)); <span class="comment">// First column in the supernode containing the column jcol</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  Index nsupc = jcol - fsupc; <span class="comment">// Number of columns in the supernode portion, excluding jcol; nsupc &gt;=0</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  Index lptr = glu.xlsub(fsupc); <span class="comment">// pointer to the starting location of the row subscripts for this supernode portion</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  Index nsupr = glu.xlsub(fsupc+1) - lptr; <span class="comment">// Number of rows in the supernode</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  Index lda = glu.xlusup(fsupc+1) - glu.xlusup(fsupc); <span class="comment">// leading dimension</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  Scalar* lu_sup_ptr = &amp;(glu.lusup.data()[glu.xlusup(fsupc)]); <span class="comment">// Start of the current supernode</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  Scalar* lu_col_ptr = &amp;(glu.lusup.data()[glu.xlusup(jcol)]); <span class="comment">// Start of jcol in the supernode</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  StorageIndex* lsub_ptr = &amp;(glu.lsub.data()[lptr]); <span class="comment">// Start of row indices of the supernode</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="comment">// Determine the largest abs numerical value for partial pivoting </span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  Index diagind = iperm_c(jcol); <span class="comment">// diagonal index </span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  RealScalar pivmax(-1.0);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  Index pivptr = nsupc; </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  Index diag = emptyIdxLU; </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  RealScalar rtemp;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  Index isub, icol, itemp, k; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="keywordflow">for</span> (isub = nsupc; isub &lt; nsupr; ++isub) {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keyword">using</span> std::abs;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    rtemp = abs(lu_col_ptr[isub]);</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">if</span> (rtemp &gt; pivmax) {</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      pivmax = rtemp; </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      pivptr = isub;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    } </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">if</span> (lsub_ptr[isub] == diagind) diag = isub;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  }</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="comment">// Test for singularity</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keywordflow">if</span> ( pivmax &lt;= RealScalar(0.0) ) {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">// if pivmax == -1, the column is structurally empty, otherwise it is only numerically zero</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    pivrow = pivmax &lt; RealScalar(0.0) ? diagind : lsub_ptr[pivptr];</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    perm_r(pivrow) = StorageIndex(jcol);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keywordflow">return</span> (jcol+1);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  }</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  RealScalar thresh = diagpivotthresh * pivmax; </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="comment">// Choose appropriate pivotal element </span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="comment">// Test if the diagonal element can be used as a pivot (given the threshold value)</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keywordflow">if</span> (diag &gt;= 0 ) </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      <span class="comment">// Diagonal element exists</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      <span class="keyword">using</span> std::abs;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      rtemp = abs(lu_col_ptr[diag]);</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      <span class="keywordflow">if</span> (rtemp != RealScalar(0.0) &amp;&amp; rtemp &gt;= thresh) pivptr = diag;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    pivrow = lsub_ptr[pivptr];</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  }</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  </div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="comment">// Record pivot row</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  perm_r(pivrow) = StorageIndex(jcol);</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="comment">// Interchange row subscripts</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">if</span> (pivptr != nsupc )</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    std::swap( lsub_ptr[pivptr], lsub_ptr[nsupc] );</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="comment">// Interchange numerical values as well, for the two rows in the whole snode</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <span class="comment">// such that L is indexed the same way as A</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordflow">for</span> (icol = 0; icol &lt;= nsupc; icol++)</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      itemp = pivptr + icol * lda; </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      std::swap(lu_sup_ptr[itemp], lu_sup_ptr[nsupc + icol * lda]);</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  }</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  <span class="comment">// cdiv operations</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  Scalar temp = Scalar(1.0) / lu_col_ptr[nsupc];</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="keywordflow">for</span> (k = nsupc+1; k &lt; nsupr; k++)</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    lu_col_ptr[k] *= temp; </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a350464d1c83182fbd7da8a5a74bdfde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350464d1c83182fbd7da8a5a74bdfde8">&#9670;&nbsp;</a></span>pruneL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::pruneL </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>jcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>perm_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>pivrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>nseg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>segrep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Ref.html">BlockIndexVector</a>&#160;</td>
          <td class="paramname"><em>repfnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>xprune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEigen_1_1internal_1_1LU__GlobalLU__t.html">GlobalLU_t</a> &amp;&#160;</td>
          <td class="paramname"><em>glu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prunes the L-structure. </p>
<p>It prunes the L-structure of supernodes whose L-structure contains the current pivot row "pivrow"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">jcol</td><td>The current column of L </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm_r</td><td>Row permutation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pivrow</td><td>The pivot row </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nseg</td><td>Number of segments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">segrep</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">repfnz</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xprune</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">glu</td><td>Global LU data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__pruneL_8h_source.html#l00053">53</a> of file <a class="el" href="SparseLU__pruneL_8h_source.html">SparseLU_pruneL.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">// For each supernode-rep irep in U(*,j]</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  Index jsupno = glu.supno(jcol); </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  Index i,irep,irep1; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="keywordtype">bool</span> movnum, do_prune = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  Index kmin = 0, kmax = 0, minloc, maxloc,krow; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="keywordflow">for</span> (i = 0; i &lt; nseg; i++)</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    irep = segrep(i); </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    irep1 = irep + 1; </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    do_prune = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="comment">// Don&#39;t prune with a zero U-segment </span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">if</span> (repfnz(irep) == emptyIdxLU) <span class="keywordflow">continue</span>; </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="comment">// If a snode overlaps with the next panel, then the U-segment</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="comment">// is fragmented into two parts -- irep and irep1. We should let </span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// pruning occur at the rep-column in irep1s snode. </span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">if</span> (glu.supno(irep) == glu.supno(irep1) ) <span class="keywordflow">continue</span>; <span class="comment">// don&#39;t prune </span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="comment">// If it has not been pruned &amp; it has a nonz in row L(pivrow,i)</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keywordflow">if</span> (glu.supno(irep) != jsupno )</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;      <span class="keywordflow">if</span> ( xprune (irep) &gt;= glu.xlsub(irep1) )</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        kmin = glu.xlsub(irep);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        kmax = glu.xlsub(irep1) - 1; </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">for</span> (krow = kmin; krow &lt;= kmax; krow++)</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;          <span class="keywordflow">if</span> (glu.lsub(krow) == pivrow) </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;          {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            do_prune = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="keywordflow">break</span>; </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;          }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        }</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;      <span class="keywordflow">if</span> (do_prune) </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="comment">// do a quicksort-type partition</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="comment">// movnum=true means that the num values have to be exchanged</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        movnum = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">if</span> (irep == glu.xsup(glu.supno(irep)) ) <span class="comment">// Snode of size 1 </span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;          movnum = <span class="keyword">true</span>; </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">while</span> (kmin &lt;= kmax)</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;          <span class="keywordflow">if</span> (perm_r(glu.lsub(kmax)) == emptyIdxLU)</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            kmax--; </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( perm_r(glu.lsub(kmin)) != emptyIdxLU)</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            kmin++;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;          <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;          {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            <span class="comment">// kmin below pivrow (not yet pivoted), and kmax</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="comment">// above pivrow: interchange the two suscripts</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            std::swap(glu.lsub(kmin), glu.lsub(kmax)); </div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            </div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;            <span class="comment">// If the supernode has only one column, then we </span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="comment">// only keep one set of subscripts. For any subscript</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;            <span class="comment">// intercnahge performed, similar interchange must be </span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="comment">// done on the numerical values. </span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            <span class="keywordflow">if</span> (movnum) </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;              minloc = glu.xlusup(irep) + ( kmin - glu.xlsub(irep) ); </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;              maxloc = glu.xlusup(irep) + ( kmax - glu.xlsub(irep) ); </div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;              std::swap(glu.lusup(minloc), glu.lusup(maxloc)); </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            }</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            kmin++;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            kmax--;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;          }</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        } <span class="comment">// end while </span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        xprune(irep) = StorageIndex(kmin);  <span class="comment">//Pruning </span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      } <span class="comment">// end if do_prune </span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    } <span class="comment">// end pruning </span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  } <span class="comment">// End for each U-segment</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33672df380f94e774c5a6919d3474af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33672df380f94e774c5a6919d3474af4">&#9670;&nbsp;</a></span>relax_snode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename StorageIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1internal_1_1SparseLUImpl.html">SparseLUImpl</a>&lt; Scalar, StorageIndex &gt;::relax_snode </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>et</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>relax_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>descendants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1Matrix.html">IndexVector</a> &amp;&#160;</td>
          <td class="paramname"><em>relax_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify the initial relaxed supernodes. </p>
<p>This routine is applied to a column elimination tree. It assumes that the matrix has been reordered according to the postorder of the etree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns </td></tr>
    <tr><td class="paramname">et</td><td>elimination tree </td></tr>
    <tr><td class="paramname">relax_columns</td><td>Maximum number of columns allowed in a relaxed snode </td></tr>
    <tr><td class="paramname">descendants</td><td>Number of descendants of each node in the etree </td></tr>
    <tr><td class="paramname">relax_end</td><td>last column in a supernode </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SparseLU__relax__snode_8h_source.html#l00047">47</a> of file <a class="el" href="SparseLU__relax__snode_8h_source.html">SparseLU_relax_snode.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="comment">// compute the number of descendants of each node in the etree</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  Index parent; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  relax_end.setConstant(emptyIdxLU);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  descendants.setZero();</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="keywordflow">for</span> (Index j = 0; j &lt; n; j++) </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    parent = et(j);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">if</span> (parent != n) <span class="comment">// not the dummy root</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;      descendants(parent) += descendants(j) + 1;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  }</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="comment">// Identify the relaxed supernodes by postorder traversal of the etree</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  Index snode_start; <span class="comment">// beginning of a snode </span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <span class="keywordflow">for</span> (Index j = 0; j &lt; n; )</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    parent = et(j);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    snode_start = j; </div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">while</span> ( parent != n &amp;&amp; descendants(parent) &lt; relax_columns ) </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      j = parent; </div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      parent = et(j);</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="comment">// Found a supernode in postordered etree, j is the last column </span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    relax_end(snode_start) = StorageIndex(j); <span class="comment">// Record last column</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    j++;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="comment">// Search for a new leaf</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">while</span> (descendants(j) != 0 &amp;&amp; j &lt; n) j++;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  } <span class="comment">// End postorder traversal of the etree</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLUImpl_8h_source.html">SparseLUImpl.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__column__bmod_8h_source.html">SparseLU_column_bmod.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__column__dfs_8h_source.html">SparseLU_column_dfs.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__copy__to__ucol_8h_source.html">SparseLU_copy_to_ucol.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__heap__relax__snode_8h_source.html">SparseLU_heap_relax_snode.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__Memory_8h_source.html">SparseLU_Memory.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__panel__bmod_8h_source.html">SparseLU_panel_bmod.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__panel__dfs_8h_source.html">SparseLU_panel_dfs.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__pivotL_8h_source.html">SparseLU_pivotL.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__pruneL_8h_source.html">SparseLU_pruneL.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__relax__snode_8h_source.html">SparseLU_relax_snode.h</a></li>
<li>Math/math_pkg/src/Eigen/src/SparseLU/<a class="el" href="SparseLU__Utils_8h_source.html">SparseLU_Utils.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aik_8cpp_html_a5bfb1324e92ea279c5738b60b67418b1"><div class="ttname"><a href="ik_8cpp.html#a5bfb1324e92ea279c5738b60b67418b1">w</a></div><div class="ttdeci">VectorXd w</div><div class="ttdef"><b>Definition:</b> <a href="ik_8cpp_source.html#l00048">ik.cpp:48</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
